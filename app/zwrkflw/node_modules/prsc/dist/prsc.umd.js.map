{"version":3,"file":"prsc.umd.js","sources":["../src/parser-combinators.ts"],"sourcesContent":["/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[]\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\tif (res.offset === offset) {\n\t\t\t\treturn error(offset, expected);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers - Parsers to attempt to apply\n */\nexport function or<T>(parsers: Parser<T>[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn lastError || error(offset, []);\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n"],"names":["okWithValue","offset","value","success","ok","undefined","error","expected","fatal","star","parser","input","ts","nextOffset","res","push","then","parser1","parser2","join","r1","r2","first","x","y","second","preceded","before","followed","after","cut","end","length","open","inner","close","cutAfterOpen","filter","map","parsers","lastError","concat","v","vs","slice","_input","token","offsetAfter"],"mappings":"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"}