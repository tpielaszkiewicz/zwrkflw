
/**
 * Creates a parser that applies the given parser and only succeeds (returning the inner parser's
 * result) if parsing concludes at the end of the input string.
 *
 * @public
 *
 * @param parser - The parser to wrap
 */
export declare function complete<T>(parser: Parser<T>): Parser<T>;

/**
 * Creates a parser that turns errors returned by the inner parser into fatal errors. Parsers such
 * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal
 * error, and will usually return the error instead.
 *
 * @public
 *
 * @param parser - The parser to wrap
 */
export declare function cut<T>(parser: Parser<T>): Parser<T>;

/**
 * Creates a Parser that applies the given parsers in sequence, returning the result value of the
 * middle parser at the offset of the third if all are successful. If any parser fails, the error is
 * returned as-is.
 *
 * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.
 *
 * @public
 *
 * @param open         - First parser to apply, value is discarded
 * @param inner        - Second parser to apply, value is kept
 * @param close        - Third parser to apply, value is discarded
 * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered
 *                       fatal, causing parsers using this to stop trying other branches.
 */
export declare function delimited<TOpen, T, TClose>(open: Parser<TOpen>, inner: Parser<T>, close: Parser<TClose>, cutAfterOpen?: boolean): Parser<T>;

/**
 * A parser that only succeeds if the end of the input string is reached.
 *
 * @public
 *
 * @param input  - The input to match in
 * @param offset - The offset in `input` at which to start matching
 */
export declare const end: Parser<void>;

/**
 * Creates an unsuccessful ParseResult (parse error) at the given offset.
 *
 * @public
 *
 * @param offset   - The offset in the input at which matching failed
 * @param expected - An array of strings indicating things that were expected at offset
 * @param fatal    - If true, no other branches should be tried as a result of this error
 */
export declare function error<T>(offset: number, expected: string[], fatal?: boolean): ParseResult<T>;

/**
 * Creates a Parser that uses the given filter predicate to check values generated by the given
 * parser. Values that pass the predicate are passed through, those that don't return a parse error
 * instead.
 *
 * @public
 *
 * @param parser   - Parser to filter
 * @param filter   - Predicate function over the inner parser's values
 * @param expected - Expected values for parse errors generated when the filter rejects a value
 */
export declare function filter<T>(parser: Parser<T>, filter: (v: T) => boolean, expected: string[]): Parser<T>;

/**
 * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also
 * `followed`.
 *
 * @public
 *
 * @param x - Argument to return
 * @param y - Argument to ignore
 */
export declare function first<T1, T2>(x: T1, y: T2): T1;

/**
 * Creates a Parser that applies the given two parsers in sequence, returning the result value of
 * the first at the offset of the second if both succeed. If either parser fails the error is
 * returned as-is.
 *
 * Equivalent to `then(parser, after, first)`.
 *
 * @public
 *
 * @param parser - First parser to apply, value is kept
 * @param before - Second parser to apply, value is discarded
 */
export declare function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T>;

/**
 * Creates a Parser that applies the given function to each value generated by the given parser.
 *
 * @public
 *
 * @param parser - Parser to map over
 * @param map    - Function to transform values generated by parser
 */
export declare function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U>;

/**
 * Creates a parser that succeeds at the starting offset if the given parser fails and vice-versa.
 *
 * @public
 *
 * @param parser   - The parser to apply
 * @param expected - Expected values for parse errors generated when the inner parser succeeds
 */
export declare function not<T>(parser: Parser<T>, expected: string[]): Parser<void>;

/**
 * Creates a successful ParseResult with an undefined value. Use this to signal success in cases
 * where no value is required.
 *
 * @public
 *
 * @param offset - The offset in the input at which to continue parsing
 */
export declare function ok(offset: number): ParseResult<undefined>;

/**
 * Creates a successful ParseResult containing the given value.
 *
 * @public
 *
 * @param offset - The offset in the input at which to continue parsing
 * @param value  - The value resulting from applying the parser
 */
export declare function okWithValue<T>(offset: number, value: T): ParseResult<T>;

/**
 * Creates a parser that tries to apply the given parser optionally. It returns the inner parser's
 * result if succesful, and otherwise indicates success at the starting offset with a `null` value.
 *
 * If the inner parser returns a fatal failure, the error is returned as-is.
 *
 * @public
 *
 * @param parser - Parser to attempt to apply
 */
export declare function optional<T>(parser: Parser<T>): Parser<T | null>;

/**
 * Creates a parser that applies each of the given parsers in turn until one matches, then returns
 * that parser's result. If no parser matches, an error is returned reflecting the furthest offset
 * reached in the input string. If any parser returns a fatal error, no further branches are tried.
 *
 * @public
 *
 * @param parsers - Parsers to attempt to apply
 */
export declare function or<T>(parsers: Parser<T>[]): Parser<T>;

/**
 * A parser is a function that tries to match whatever it expects at the given offset in the input
 * string. Returns a ParseResult.
 *
 * @public
 */
export declare type Parser<T> = (input: string, offset: number) => ParseResult<T>;

/**
 * The result of parsing - either success (with an offset at which to resume parsing the next thing)
 * or failure. If a failure is fatal, parsing should not continue to try alternative options.
 *
 * A ParseResult may contain a value that represents the parsed input.
 *
 * @public
 */
export declare type ParseResult<T> = {
    success: true;
    offset: number;
    value: T;
} | {
    success: false;
    offset: number;
    expected: string[];
    fatal: boolean;
};

/**
 * Creates a parser that applies the given parser without consuming any input. That is, if the inner
 * parser is successful, success is returned (with the resulting value) at the starting offset,
 * effectively making the parser consume no input.
 *
 * Errors returned by the inner parser are returned as-is.
 *
 * @public
 *
 * @param parser - The parser to apply, value is discarded and any progress made in input is reset.
 */
export declare function peek<T>(parser: Parser<T>): Parser<T>;

/**
 * Creates a parser that tries to apply the given parser one or more times in sequence. Values for
 * successful matches are collected in an array. Once the inner parser no longer matches, success is
 * returned at the offset reached with the accumulated values. The parser is required to match at
 * least once, so an initial failure is returned as-is.
 *
 * If the inner parser returns a fatal failure, the error is returned as-is.
 *
 * @public
 *
 * @param parser - The parser to apply repeatedly
 */
export declare function plus<T>(parser: Parser<T>): Parser<T[]>;

/**
 * Creates a Parser that applies the given two parsers in sequence, returning the result of the
 * second if the first succeeds.
 *
 * Equivalent to `then(before, parser, second)`.
 *
 * @public
 *
 * @param before - First parser to apply, value is discarded
 * @param parser - Second parser to apply, value is kept
 */
export declare function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T>;

/**
 * Creates a parser that applies the given parser. If successful, the inner parser's value is
 * discarded and the substring that was consumed from the input is returned as value instead. Errors
 * are returned as-is.
 *
 * @public
 *
 * @param parser - The parser to apply, value is discarded and replaced by the consumed input.
 */
export declare function recognize<T>(parser: Parser<T>): Parser<string>;

/**
 * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also
 * `preceded`.
 *
 * @public
 *
 * @param x - Argument to ignore
 * @param y - Argument to return
 */
export declare function second<T1, T2>(x: T1, y: T2): T2;

/**
 * Creates a parser that tries to apply the given parser zero or more times in sequence. Values for
 * successful matches are collected in an array. Once the inner parser no longer matches, success is
 * returned at the offset reached with the accumulated values.
 *
 * If the inner parser returns a fatal failure, the error is returned as-is.
 *
 * @public
 *
 * @param parser - Parser to apply repeatedly
 */
export declare function star<T>(parser: Parser<T>): Parser<T[]>;

/**
 * A parser that only succeeds at the start of the input string.
 *
 * @public
 *
 * @param input  - The input to match in
 * @param offset - The offset in `input` at which to start matching
 */
export declare const start: Parser<void>;

/**
 * Creates a parser that applies the given two parsers in sequence, returning success only if both
 * succeed. The given join function is used to combine the values from both parsers into the single
 * value to return. If either parser fails, the failure is returned as-is.
 *
 * @public
 *
 * @param parser1 - First parser to apply
 * @param parser2 - Parser to apply after the first one is successful
 * @param join    - Function used to combine the values of both parsers
 */
export declare function then<T1, T2, T>(parser1: Parser<T1>, parser2: Parser<T2>, join: (value1: T1, value2: T2) => T): Parser<T>;

/**
 * Creates a Parser that matches the given string.
 *
 * @public
 *
 * @param token - The expected string
 */
export declare function token(token: string): Parser<string>;

export { }
