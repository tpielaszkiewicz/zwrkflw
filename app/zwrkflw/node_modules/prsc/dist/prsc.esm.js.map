{"version":3,"file":"prsc.esm.js","sources":["../src/parser-combinators.ts"],"sourcesContent":["/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[]\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\tif (res.offset === offset) {\n\t\t\t\treturn error(offset, expected);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers - Parsers to attempt to apply\n */\nexport function or<T>(parsers: Parser<T>[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn lastError || error(offset, []);\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n"],"names":["okWithValue","offset","value","success","ok","undefined","error","expected","fatal","token","input","offsetAfter","length","slice","map","parser","res","filter","or","parsers","lastError","concat","optional","star","ts","nextOffset","push","then","parser1","parser2","join","r1","r2","plus","v","vs","first","x","y","second","preceded","before","followed","after","delimited","open","inner","close","cutAfterOpen","cut","recognize","peek","not","start","_input","end","complete"],"mappings":"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"}