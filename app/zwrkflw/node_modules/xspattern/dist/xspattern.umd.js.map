{"version":3,"file":"xspattern.umd.js","sources":["../src/basic-sets.ts","../src/compiler.ts","../node_modules/prsc/src/parser-combinators.ts","../src/unicode-categories.ts","../src/sets.ts","../src/unicode-blocks.ts","../src/parser.ts","../src/index.ts"],"sourcesContent":["import { Codepoint, Predicate } from './types';\n\nexport function singleChar(expected: Codepoint): Predicate {\n\treturn (codepoint) => codepoint === expected;\n}\n\nexport function charRange(first: Codepoint | null, last: Codepoint | null): Predicate {\n\t// It is an error if either of the two singleChars in a charRange is a\n\t// SingleCharNoEsc comprising an unescaped hyphen\n\tif (first === null || last === null) {\n\t\tthrow new Error('unescaped hyphen may not be used as a range endpoint');\n\t}\n\n\t// Inverted range is not explicitly disallowed by the XML Schema 1.1 spec,\n\t// but is forbidden by the XML Schema Part 2: Datatypes Second Edition spec.\n\t// Let's adopt the 1.0 behavior, as the XML Schema test suite seems to agree\n\tif (last < first) {\n\t\tthrow new Error('character range is in the wrong order');\n\t}\n\n\treturn (codepoint) => first <= codepoint && codepoint <= last;\n}\n\nexport function everything(_codepoint: Codepoint): boolean {\n\treturn true;\n}\n\nexport function nothing(): boolean {\n\treturn false;\n}\n\nexport function union(first: Predicate, next: Predicate): Predicate {\n\treturn (codepoint) => first(codepoint) || next(codepoint);\n}\n\nexport const INPUT_START_SENTINEL = -1;\nexport const INPUT_END_SENTINEL = -2;\n","import { Assembler } from 'whynot';\nimport { RegExp, Branch, Piece, Atom } from './ast';\n\ntype RegExpAssembler = Assembler<number, void>;\n\nfunction compileAtom(assembler: RegExpAssembler, atom: Atom): void {\n\tswitch (atom.kind) {\n\t\tcase 'predicate': {\n\t\t\t// Value is a predicate function for some character class\n\t\t\tassembler.test(atom.value);\n\t\t\treturn;\n\t\t}\n\n\t\tcase 'regexp':\n\t\t\t// Value is a nested RegExp\n\t\t\tcompileRegExp(assembler, atom.value, false);\n\t\t\treturn;\n\t}\n}\n\nfunction compilePiece(assembler: RegExpAssembler, piece: Piece): void {\n\t// Atom and quantifier\n\tconst [atomAst, { min, max }] = piece;\n\tif (max === null) {\n\t\t// Unbounded repetition\n\t\tif (min > 0) {\n\t\t\tfor (let i = 0; i < min - 1; ++i) {\n\t\t\t\tcompileAtom(assembler, atomAst);\n\t\t\t}\n\t\t\t// Efficient \"1 or more\" loop\n\t\t\tconst start = assembler.program.length;\n\t\t\tcompileAtom(assembler, atomAst);\n\t\t\tconst fork = assembler.jump([start]);\n\t\t\tfork.data.push(assembler.program.length);\n\t\t} else {\n\t\t\t// Optional unbounded loop\n\t\t\tconst start = assembler.program.length;\n\t\t\tconst fork = assembler.jump([]);\n\t\t\t// Match and loop...\n\t\t\tfork.data.push(assembler.program.length);\n\t\t\tcompileAtom(assembler, atomAst);\n\t\t\tassembler.jump([start]);\n\t\t\t// ...or skip\n\t\t\tfork.data.push(assembler.program.length);\n\t\t}\n\t\treturn;\n\t}\n\n\t// Bounded repetition\n\tfor (let i = 0; i < min; ++i) {\n\t\tcompileAtom(assembler, atomAst);\n\t}\n\tfor (let i = min; i < max; ++i) {\n\t\tconst fork = assembler.jump([]);\n\t\t// Match...\n\t\tfork.data.push(assembler.program.length);\n\t\tcompileAtom(assembler, atomAst);\n\t\t// ...or skip\n\t\tfork.data.push(assembler.program.length);\n\t}\n}\n\nfunction compileBranch(assembler: RegExpAssembler, branch: Branch): void {\n\t// Sequence of pieces\n\tbranch.forEach((piece) => {\n\t\tcompilePiece(assembler, piece);\n\t});\n}\n\nexport function compileRegExp(\n\tassembler: RegExpAssembler,\n\tregExp: RegExp,\n\tmatchSubstring: boolean\n): void {\n\tconst start = assembler.program.length;\n\n\t// Disjunction of branches\n\tconst fork = assembler.jump([]);\n\n\t// If we are compiling an XPath-style pattern, add a set of jumps and accepts to add the 'match\n\t// anywhere' behavior at the start.\n\tif (matchSubstring) {\n\t\tfork.data.push(assembler.program.length);\n\t\tassembler.test(() => true);\n\t\tassembler.jump([start]);\n\t}\n\n\t// TODO: I should really export Instruction from whynot...\n\tconst joins: typeof fork[] = [];\n\tregExp.forEach((branch) => {\n\t\tfork.data.push(assembler.program.length);\n\t\tcompileBranch(assembler, branch);\n\t\tjoins.push(assembler.jump([]));\n\t});\n\tjoins.forEach((join) => {\n\t\tjoin.data.push(assembler.program.length);\n\t});\n\n\t// Add a jump and all-accepting test for the 'end' of the program to add the 'match anything'\n\t// behavior at the end.\n\tif (matchSubstring) {\n\t\tconst beforeFork = assembler.program.length;\n\t\tconst forkForEnd = assembler.jump([]);\n\t\tforkForEnd.data.push(assembler.program.length);\n\t\t// Allow everything\n\t\tassembler.test(() => true);\n\t\t// And allow it multiple times\n\t\tassembler.jump([beforeFork]);\n\t\t// Or skip it completely\n\t\tforkForEnd.data.push(assembler.program.length);\n\t}\n}\n","/**\n * The result of parsing - either success (with an offset at which to resume parsing the next thing)\n * or failure. If a failure is fatal, parsing should not continue to try alternative options.\n *\n * A ParseResult may contain a value that represents the parsed input.\n *\n * @public\n */\nexport type ParseResult<T> =\n\t| { success: true; offset: number; value: T }\n\t| { success: false; offset: number; expected: string[]; fatal: boolean };\n\n/**\n * A parser is a function that tries to match whatever it expects at the given offset in the input\n * string. Returns a ParseResult.\n *\n * @public\n */\nexport type Parser<T> = (input: string, offset: number) => ParseResult<T>;\n\n/**\n * Creates a successful ParseResult containing the given value.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n * @param value  - The value resulting from applying the parser\n */\nexport function okWithValue<T>(offset: number, value: T): ParseResult<T> {\n\treturn { success: true, offset, value };\n}\n\n/**\n * Creates a successful ParseResult with an undefined value. Use this to signal success in cases\n * where no value is required.\n *\n * @public\n *\n * @param offset - The offset in the input at which to continue parsing\n */\nexport function ok(offset: number): ParseResult<undefined> {\n\treturn okWithValue(offset, undefined);\n}\n\n/**\n * Creates an unsuccessful ParseResult (parse error) at the given offset.\n *\n * @public\n *\n * @param offset   - The offset in the input at which matching failed\n * @param expected - An array of strings indicating things that were expected at offset\n * @param fatal    - If true, no other branches should be tried as a result of this error\n */\nexport function error<T>(\n\toffset: number,\n\texpected: string[],\n\tfatal: boolean = false\n): ParseResult<T> {\n\treturn { success: false, offset, expected, fatal };\n}\n\n/**\n * Creates a Parser that matches the given string.\n *\n * @public\n *\n * @param token - The expected string\n */\nexport function token(token: string): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst offsetAfter = offset + token.length;\n\t\tif (input.slice(offset, offsetAfter) === token) {\n\t\t\treturn okWithValue(offsetAfter, token);\n\t\t}\n\t\treturn error(offset, [token]);\n\t};\n}\n\n/**\n * Creates a Parser that applies the given function to each value generated by the given parser.\n *\n * @public\n *\n * @param parser - Parser to map over\n * @param map    - Function to transform values generated by parser\n */\nexport function map<T, U>(parser: Parser<T>, map: (v: T) => U): Parser<U> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, map(res.value));\n\t};\n}\n\n/**\n * Creates a Parser that uses the given filter predicate to check values generated by the given\n * parser. Values that pass the predicate are passed through, those that don't return a parse error\n * instead.\n *\n * @public\n *\n * @param parser   - Parser to filter\n * @param filter   - Predicate function over the inner parser's values\n * @param expected - Expected values for parse errors generated when the filter rejects a value\n */\nexport function filter<T>(\n\tparser: Parser<T>,\n\tfilter: (v: T) => boolean,\n\texpected: string[]\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\tif (res.offset === offset) {\n\t\t\t\treturn error(offset, expected);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\tif (!filter(res.value)) {\n\t\t\treturn error(offset, expected);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a parser that applies each of the given parsers in turn until one matches, then returns\n * that parser's result. If no parser matches, an error is returned reflecting the furthest offset\n * reached in the input string. If any parser returns a fatal error, no further branches are tried.\n *\n * @public\n *\n * @param parsers - Parsers to attempt to apply\n */\nexport function or<T>(parsers: Parser<T>[]): Parser<T> {\n\treturn (input, offset) => {\n\t\tlet lastError: ParseResult<T> | null = null;\n\t\tfor (const parser of parsers) {\n\t\t\tconst res = parser(input, offset);\n\t\t\tif (res.success) {\n\t\t\t\treturn res;\n\t\t\t}\n\n\t\t\tif (lastError === null || res.offset > lastError.offset) {\n\t\t\t\tlastError = res;\n\t\t\t} else if (res.offset === lastError.offset) {\n\t\t\t\tlastError.expected = lastError.expected.concat(res.expected);\n\t\t\t}\n\t\t\tif (res.fatal) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn lastError || error(offset, []);\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser optionally. It returns the inner parser's\n * result if succesful, and otherwise indicates success at the starting offset with a `null` value.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to attempt to apply\n */\nexport function optional<T>(parser: Parser<T>): Parser<T | null> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success && !res.fatal) {\n\t\t\treturn okWithValue(offset, null);\n\t\t}\n\n\t\treturn res;\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser zero or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - Parser to apply repeatedly\n */\nexport function star<T>(parser: Parser<T>): Parser<T[]> {\n\treturn (input, offset) => {\n\t\tlet ts: T[] = [];\n\t\tlet nextOffset = offset;\n\t\twhile (true) {\n\t\t\tconst res = parser(input, nextOffset);\n\t\t\tif (!res.success) {\n\t\t\t\tif (res.fatal) {\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tts.push(res.value);\n\t\t\tnextOffset = res.offset;\n\t\t}\n\n\t\treturn okWithValue(nextOffset, ts);\n\t};\n}\n\n/**\n * Creates a parser that applies the given two parsers in sequence, returning success only if both\n * succeed. The given join function is used to combine the values from both parsers into the single\n * value to return. If either parser fails, the failure is returned as-is.\n *\n * @public\n *\n * @param parser1 - First parser to apply\n * @param parser2 - Parser to apply after the first one is successful\n * @param join    - Function used to combine the values of both parsers\n */\nexport function then<T1, T2, T>(\n\tparser1: Parser<T1>,\n\tparser2: Parser<T2>,\n\tjoin: (value1: T1, value2: T2) => T\n): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst r1 = parser1(input, offset);\n\t\tif (!r1.success) {\n\t\t\treturn r1;\n\t\t}\n\t\tconst r2 = parser2(input, r1.offset);\n\t\tif (!r2.success) {\n\t\t\treturn r2;\n\t\t}\n\t\treturn okWithValue(r2.offset, join(r1.value, r2.value));\n\t};\n}\n\n/**\n * Creates a parser that tries to apply the given parser one or more times in sequence. Values for\n * successful matches are collected in an array. Once the inner parser no longer matches, success is\n * returned at the offset reached with the accumulated values. The parser is required to match at\n * least once, so an initial failure is returned as-is.\n *\n * If the inner parser returns a fatal failure, the error is returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply repeatedly\n */\nexport function plus<T>(parser: Parser<T>): Parser<T[]> {\n\treturn then(parser, star(parser), (v, vs) => [v].concat(vs));\n}\n\n/**\n * Returns the first of the given two arguments. Useful as a `join` function for `then`. See also\n * `followed`.\n *\n * @public\n *\n * @param x - Argument to return\n * @param y - Argument to ignore\n */\nexport function first<T1, T2>(x: T1, y: T2): T1 {\n\treturn x;\n}\n\n/**\n * Returns the second of the given two arguments. Useful as a `join` function for `then`. See also\n * `preceded`.\n *\n * @public\n *\n * @param x - Argument to ignore\n * @param y - Argument to return\n */\nexport function second<T1, T2>(x: T1, y: T2): T2 {\n\treturn y;\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result of the\n * second if the first succeeds.\n *\n * Equivalent to `then(before, parser, second)`.\n *\n * @public\n *\n * @param before - First parser to apply, value is discarded\n * @param parser - Second parser to apply, value is kept\n */\nexport function preceded<TBefore, T>(before: Parser<TBefore>, parser: Parser<T>): Parser<T> {\n\treturn then(before, parser, second);\n}\n\n/**\n * Creates a Parser that applies the given two parsers in sequence, returning the result value of\n * the first at the offset of the second if both succeed. If either parser fails the error is\n * returned as-is.\n *\n * Equivalent to `then(parser, after, first)`.\n *\n * @public\n *\n * @param parser - First parser to apply, value is kept\n * @param before - Second parser to apply, value is discarded\n */\nexport function followed<T, TAfter>(parser: Parser<T>, after: Parser<TAfter>): Parser<T> {\n\treturn then(parser, after, first);\n}\n\n/**\n * Creates a Parser that applies the given parsers in sequence, returning the result value of the\n * middle parser at the offset of the third if all are successful. If any parser fails, the error is\n * returned as-is.\n *\n * Optionally makes errors by the second and third parsers fatal if `cutAfterOpen` is `true`.\n *\n * @public\n *\n * @param open         - First parser to apply, value is discarded\n * @param inner        - Second parser to apply, value is kept\n * @param close        - Third parser to apply, value is discarded\n * @param cutAfterOpen - If `true`, errors returned by the second and third parsers are considered\n *                       fatal, causing parsers using this to stop trying other branches.\n */\nexport function delimited<TOpen, T, TClose>(\n\topen: Parser<TOpen>,\n\tinner: Parser<T>,\n\tclose: Parser<TClose>,\n\tcutAfterOpen: boolean = false\n): Parser<T> {\n\tconst rest = cutAfterOpen ? cut(followed(inner, close)) : followed(inner, close);\n\treturn preceded(open, rest);\n}\n\n/**\n * Creates a parser that applies the given parser. If successful, the inner parser's value is\n * discarded and the substring that was consumed from the input is returned as value instead. Errors\n * are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and replaced by the consumed input.\n */\nexport function recognize<T>(parser: Parser<T>): Parser<string> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(res.offset, input.slice(offset, res.offset));\n\t};\n}\n\n/**\n * Creates a parser that applies the given parser without consuming any input. That is, if the inner\n * parser is successful, success is returned (with the resulting value) at the starting offset,\n * effectively making the parser consume no input.\n *\n * Errors returned by the inner parser are returned as-is.\n *\n * @public\n *\n * @param parser - The parser to apply, value is discarded and any progress made in input is reset.\n */\nexport function peek<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn res;\n\t\t}\n\t\treturn okWithValue(offset, res.value);\n\t};\n}\n\n/**\n * Creates a parser that succeeds at the starting offset if the given parser fails and vice-versa.\n *\n * @public\n *\n * @param parser   - The parser to apply\n * @param expected - Expected values for parse errors generated when the inner parser succeeds\n */\nexport function not<T>(parser: Parser<T>, expected: string[]): Parser<void> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn ok(offset);\n\t\t}\n\t\treturn error(offset, expected);\n\t};\n}\n\n/**\n * Creates a parser that turns errors returned by the inner parser into fatal errors. Parsers such\n * as `or` and `star` will not continue to attempt additional matches if a parser returns a fatal\n * error, and will usually return the error instead.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function cut<T>(parser: Parser<T>): Parser<T> {\n\treturn (input, offset) => {\n\t\tconst res = parser(input, offset);\n\t\tif (!res.success) {\n\t\t\treturn error(res.offset, res.expected, true);\n\t\t}\n\t\treturn res;\n\t};\n}\n\n/**\n * A parser that only succeeds at the start of the input string.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const start: Parser<void> = (_input, offset) =>\n\toffset === 0 ? ok(offset) : error(offset, ['start of input']);\n\n/**\n * A parser that only succeeds if the end of the input string is reached.\n *\n * @public\n *\n * @param input  - The input to match in\n * @param offset - The offset in `input` at which to start matching\n */\nexport const end: Parser<void> = (input, offset) =>\n\tinput.length === offset ? ok(offset) : error(offset, ['end of input']);\n\n/**\n * Creates a parser that applies the given parser and only succeeds (returning the inner parser's\n * result) if parsing concludes at the end of the input string.\n *\n * @public\n *\n * @param parser - The parser to wrap\n */\nexport function complete<T>(parser: Parser<T>): Parser<T> {\n\treturn then(parser, end, first);\n}\n","import { charRange, nothing, singleChar, union } from './basic-sets';\nimport { Codepoint, Predicate } from './types';\n\nexport const CATEGORIES = [\n\t'Lu',\n\t'Ll',\n\t'Lt',\n\t'Lm',\n\t'Lo',\n\t'Mn',\n\t'Mc',\n\t'Me',\n\t'Nd',\n\t'Nl',\n\t'No',\n\t'Pc',\n\t'Pd',\n\t'Ps',\n\t'Pe',\n\t'Pi',\n\t'Pf',\n\t'Po',\n\t'Zs',\n\t'Zl',\n\t'Zp',\n\t'Sm',\n\t'Sc',\n\t'Sk',\n\t'So',\n\t'Cc',\n\t'Cf',\n\t'Co',\n\t'Cn',\n];\n\ntype UnicodeDataEntry = {\n\tcodepoint: Codepoint;\n\tname: string | null;\n\tcategory: string | null;\n\tcatIndex: number;\n};\n\nfunction* parseUnicodeData(data: string): Iterable<UnicodeDataEntry> {\n\tfor (const line of data.split('\\n')) {\n\t\tconst trimmed = line.trim();\n\t\tif (trimmed === '') {\n\t\t\tcontinue;\n\t\t}\n\t\tconst [codepointHex, name, category] = trimmed.split(';');\n\t\tconst codepoint = parseInt(codepointHex, 16);\n\n\t\tconst catIndex = CATEGORIES.indexOf(category);\n\t\tif (catIndex === -1) {\n\t\t\t// Category is not supported by the parser, so we can ignore it. Currently, this is only\n\t\t\t// Cs (surrogates), which will never match as we consider input as full codepoints only.\n\t\t\tcontinue;\n\t\t}\n\n\t\tyield { codepoint, name, category, catIndex };\n\t}\n}\n\nfunction* withExpandedRanges(entries: Iterable<UnicodeDataEntry>): Iterable<UnicodeDataEntry> {\n\tlet previousCodepoint = -1;\n\tfor (const entry of entries) {\n\t\tconst isRangeStart = entry.name !== null && entry.name.endsWith(', First>');\n\t\tconst isRangeEnd = entry.name !== null && entry.name.endsWith(', Last>');\n\t\tif (isRangeStart) {\n\t\t\tpreviousCodepoint = entry.codepoint;\n\t\t\tcontinue;\n\t\t}\n\t\tif (isRangeEnd) {\n\t\t\tfor (let codepoint = previousCodepoint; codepoint < entry.codepoint; ++codepoint) {\n\t\t\t\tyield { ...entry, codepoint };\n\t\t\t}\n\t\t}\n\t\tyield entry;\n\t}\n}\n\nfunction* withExpandedGaps(entries: Iterable<UnicodeDataEntry>): Iterable<UnicodeDataEntry> {\n\tlet previousCodepoint = -1;\n\tfor (const entry of entries) {\n\t\tfor (let codepoint = previousCodepoint + 1; codepoint < entry.codepoint; ++codepoint) {\n\t\t\tyield { codepoint, name: null, category: null, catIndex: -1 };\n\t\t}\n\t\tyield entry;\n\t\tpreviousCodepoint = entry.codepoint;\n\t}\n}\n\ntype AlternationState = 'out' | 'lower' | 'upper';\n\nfunction* withAlternationCategory(entries: Iterable<UnicodeDataEntry>): Iterable<UnicodeDataEntry> {\n\tlet first: UnicodeDataEntry | null = null;\n\tlet second: UnicodeDataEntry | null = null;\n\tlet state: AlternationState = 'out';\n\tfor (let entry of entries) {\n\t\tswitch (state) {\n\t\t\tcase 'out':\n\t\t\t\t// Start a new sequence?\n\t\t\t\tif (\n\t\t\t\t\tfirst !== null &&\n\t\t\t\t\tsecond !== null &&\n\t\t\t\t\tfirst.category === 'Lu' &&\n\t\t\t\t\tsecond.category === 'Ll' &&\n\t\t\t\t\tentry.category === 'Lu'\n\t\t\t\t) {\n\t\t\t\t\tstate = 'lower';\n\t\t\t\t\tfirst = { ...first, category: 'LuLl', catIndex: -2 };\n\t\t\t\t\tsecond = { ...second, category: 'LuLl', catIndex: -2 };\n\t\t\t\t\tentry = { ...entry, category: 'LuLl', catIndex: -2 };\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'lower':\n\t\t\t\tif (entry.category === 'Ll') {\n\t\t\t\t\tentry = { ...entry, category: 'LuLl', catIndex: -2 };\n\t\t\t\t\tstate = 'upper';\n\t\t\t\t} else {\n\t\t\t\t\t// If the alternation is broken by a double upper case, reset second to avoid\n\t\t\t\t\t// creating adjacent alternations\n\t\t\t\t\tif (entry.category === 'Lu' && second !== null) {\n\t\t\t\t\t\tsecond = { ...second, category: 'Lu', catIndex: 0 };\n\t\t\t\t\t}\n\t\t\t\t\tstate = 'out';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'upper':\n\t\t\t\tif (entry.category === 'Lu') {\n\t\t\t\t\tentry = { ...entry, category: 'LuLl', catIndex: -2 };\n\t\t\t\t\tstate = 'lower';\n\t\t\t\t} else {\n\t\t\t\t\tstate = 'out';\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\tif (first !== null) {\n\t\t\tyield first;\n\t\t}\n\t\tfirst = second;\n\t\tsecond = entry;\n\t}\n\tif (first !== null) {\n\t\tyield first;\n\t}\n\tif (second !== null) {\n\t\tyield second;\n\t}\n}\n\nexport type UnicodeDataRange = { start: number; end: number; catIndex: number };\n\nfunction* asRanges(entries: Iterable<UnicodeDataEntry>): Iterable<UnicodeDataRange> {\n\tlet previousEntry = null;\n\tlet rangeStart = 0;\n\tfor (const entry of entries) {\n\t\tif (previousEntry !== null && entry.catIndex !== previousEntry.catIndex) {\n\t\t\tyield {\n\t\t\t\tstart: rangeStart,\n\t\t\t\tend: previousEntry.codepoint,\n\t\t\t\tcatIndex: previousEntry.catIndex,\n\t\t\t};\n\t\t\trangeStart = entry.codepoint;\n\t\t}\n\t\tpreviousEntry = entry;\n\t}\n\n\tif (previousEntry !== null) {\n\t\tyield { start: rangeStart, end: previousEntry.codepoint, catIndex: previousEntry.catIndex };\n\t}\n}\n\nconst base64ByNumber = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction* encodeRange(range: UnicodeDataRange): Iterable<string> {\n\t// Length 0 never happens, so let's not waste the A and subtract one in advance\n\tconst length = range.end - range.start;\n\tlet catIndex = range.catIndex + 2;\n\tlet encodedLength: string;\n\tif (length < base64ByNumber.length) {\n\t\tencodedLength = base64ByNumber.charAt(length);\n\t} else {\n\t\tcatIndex |= 0b100000;\n\t\tconst mask = 0b111111;\n\t\tencodedLength = [\n\t\t\tlength & mask,\n\t\t\t(length >> 6) & mask,\n\t\t\t(length >> 12) & mask,\n\t\t\t(length >> 18) & mask,\n\t\t]\n\t\t\t.map((n) => base64ByNumber.charAt(n))\n\t\t\t.join('');\n\t}\n\t// category\n\tyield base64ByNumber.charAt(catIndex);\n\t// length\n\tyield encodedLength;\n}\n\nexport function* encode(ranges: Iterable<UnicodeDataRange>): Iterable<string> {\n\tfor (const range of ranges) {\n\t\tyield* encodeRange(range);\n\t}\n}\n\nexport function packCategories(data: string): string {\n\tconst codepoints = withAlternationCategory(\n\t\twithExpandedGaps(withExpandedRanges(parseUnicodeData(data)))\n\t);\n\tconst ranges = asRanges(codepoints);\n\tconst mapping = [...encode(ranges)].join('');\n\n\treturn mapping;\n}\n\nconst numberByBase64: { [key: string]: number } = {};\n'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('').forEach((c, i) => {\n\tnumberByBase64[c] = i;\n});\n\nexport function unpackCategories(packed: string): Map<string, Predicate> {\n\tconst predicateByCategory: Map<string, Predicate> = new Map();\n\tconst encodedMapping = packed.split('');\n\tconst partsByCatIndex: Predicate[][] = CATEGORIES.map(() => []);\n\tlet first = 0;\n\tlet i = 0;\n\twhile (i < encodedMapping.length) {\n\t\tconst encodedCatIndex = numberByBase64[encodedMapping[i]];\n\t\tconst catIndex = (encodedCatIndex & 0b11111) - 2;\n\t\tlet length = 1 + numberByBase64[encodedMapping[i + 1]];\n\t\tif (encodedCatIndex & 0b100000) {\n\t\t\tlength += numberByBase64[encodedMapping[i + 2]] << 6;\n\t\t\tlength += numberByBase64[encodedMapping[i + 3]] << 12;\n\t\t\tlength += numberByBase64[encodedMapping[i + 4]] << 18;\n\t\t\ti += 5;\n\t\t} else {\n\t\t\ti += 2;\n\t\t}\n\t\tswitch (catIndex) {\n\t\t\tcase -2: {\n\t\t\t\tlet actualCatIndex = 0;\n\t\t\t\tfor (let codepoint = first; codepoint < first + length; ++codepoint) {\n\t\t\t\t\tconst parts = partsByCatIndex[actualCatIndex];\n\t\t\t\t\tparts.push(singleChar(codepoint));\n\t\t\t\t\tactualCatIndex = (actualCatIndex + 1) % 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcase -1:\n\t\t\t\t// Gap, ignore\n\t\t\t\tbreak;\n\n\t\t\tdefault: {\n\t\t\t\tconst parts = partsByCatIndex[catIndex];\n\t\t\t\tif (length === 1) {\n\t\t\t\t\tparts.push(singleChar(first));\n\t\t\t\t} else {\n\t\t\t\t\tparts.push(charRange(first, first + length - 1));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfirst += length;\n\t}\n\tconst partsByPrefix: Map<string, Predicate[]> = new Map();\n\tCATEGORIES.forEach((category, i) => {\n\t\tconst predicate = partsByCatIndex[i].reduce(union, nothing);\n\t\tpredicateByCategory.set(category, predicate);\n\t\tconst prefix = category.charAt(0);\n\t\tconst parts = partsByPrefix.get(prefix) || [];\n\t\tpartsByPrefix.set(prefix, parts);\n\t\tparts.push(predicate);\n\t});\n\tpartsByPrefix.forEach((parts, prefix) => {\n\t\tpredicateByCategory.set(prefix, parts.reduce(union, nothing));\n\t});\n\treturn predicateByCategory;\n}\n","import {\n\tcharRange,\n\teverything,\n\tINPUT_END_SENTINEL,\n\tINPUT_START_SENTINEL,\n\tsingleChar,\n\tunion,\n} from './basic-sets';\nimport { lengths as blockLengths, names as blockNames } from './generated/blocks.json';\nimport categories from './generated/categories.json';\nimport { Codepoint, Predicate } from './types';\nimport { unpackBlocks } from './unicode-blocks';\nimport { unpackCategories } from './unicode-categories';\n\nexport { charRange, singleChar, union } from './basic-sets';\n\nexport function asCodepoint(char: string): Codepoint {\n\treturn char.codePointAt(0)!;\n}\n\nconst sentinel: Predicate = (codepoint) =>\n\tcodepoint === INPUT_START_SENTINEL || codepoint === INPUT_END_SENTINEL;\n\nexport function complement(predicate: Predicate): Predicate {\n\treturn (codepoint) => !sentinel(codepoint) && !predicate(codepoint);\n}\n\nexport function difference(predicate: Predicate, except: Predicate | null): Predicate {\n\tif (except === null) {\n\t\treturn predicate;\n\t}\n\treturn (codepoint) => predicate(codepoint) && !except(codepoint);\n}\n\nconst predicateByNormalizedBlockId: Map<string, Predicate> = unpackBlocks(blockNames, blockLengths);\nconst predicateByCategory: Map<string, Predicate> = unpackCategories(categories);\n\nexport function unicodeBlock(identifier: string, acceptUnknownBlocks: boolean): Predicate {\n\t// The matching engine is not required to normalize the block identifier in the regexp\n\tconst predicate = predicateByNormalizedBlockId.get(identifier);\n\tif (predicate === undefined) {\n\t\tif (acceptUnknownBlocks) {\n\t\t\t// Unknown blocks should match every character\n\t\t\treturn everything;\n\t\t}\n\n\t\tthrow new Error(`The unicode block identifier \"${identifier}\" is not known.`);\n\t}\n\treturn predicate;\n}\n\nexport function unicodeCategory(identifier: string): Predicate {\n\tconst predicate = predicateByCategory.get(identifier);\n\t// If is unreachable, as the parser will never match unsupported identifiers\n\t/* istanbul ignore if */\n\tif (predicate == undefined) {\n\t\tthrow new Error(`${identifier} is not a valid unicode category`);\n\t}\n\treturn predicate;\n}\n\nfunction whitespace(codepoint: Codepoint): boolean {\n\t// space, tab, newline, carriage return\n\treturn codepoint === 0x20 || codepoint === 0x9 || codepoint === 0xa || codepoint === 0xd;\n}\n\n// From XML 1.1\nconst nameStartChar = [\n\tsingleChar(asCodepoint(':')),\n\tcharRange(asCodepoint('A'), asCodepoint('Z')),\n\tsingleChar(asCodepoint('_')),\n\tcharRange(asCodepoint('a'), asCodepoint('z')),\n\tcharRange(0xc0, 0xd6),\n\tcharRange(0xd8, 0xf6),\n\tcharRange(0xc0, 0xd6),\n\tcharRange(0xd8, 0xf6),\n\tcharRange(0xf8, 0x2ff),\n\tcharRange(0x370, 0x37d),\n\tcharRange(0x37f, 0x1fff),\n\tcharRange(0x200c, 0x200d),\n\tcharRange(0x2070, 0x218f),\n\tcharRange(0x2c00, 0x2fef),\n\tcharRange(0x3001, 0xd7ff),\n\tcharRange(0xf900, 0xfdcf),\n\tcharRange(0xfdf0, 0xfffd),\n\tcharRange(0x10000, 0xeffff),\n].reduce(union);\n\nconst nameChar = [\n\tnameStartChar,\n\tsingleChar(asCodepoint('-')),\n\tsingleChar(asCodepoint('.')),\n\tcharRange(asCodepoint('0'), asCodepoint('9')),\n\tsingleChar(0xb7),\n\tcharRange(0x300, 0x36f),\n\tcharRange(0x203f, 0x2040),\n].reduce(union);\n\nconst digit = predicateByCategory.get('Nd')!;\nconst notDigit = complement(digit);\nconst wordChar = difference(\n\tcharRange(0x0000, 0x10ffff),\n\t[\n\t\tpredicateByCategory.get('P')!,\n\t\tpredicateByCategory.get('Z')!,\n\t\tpredicateByCategory.get('C')!,\n\t].reduce(union)\n);\nconst notWordChar = complement(wordChar);\n\nexport function wildcard(codepoint: Codepoint): boolean {\n\t// Anything except newline, carriage return and the start / end sentinels\n\treturn codepoint !== 0xa && codepoint !== 0xd && !sentinel(codepoint);\n}\n\nexport const multiChar = {\n\ts: whitespace,\n\tS: complement(whitespace),\n\ti: nameStartChar,\n\tI: complement(nameStartChar),\n\tc: nameChar,\n\tC: complement(nameChar),\n\td: digit,\n\tD: notDigit,\n\tw: wordChar,\n\tW: notWordChar,\n};\n","import { charRange, union } from './basic-sets';\nimport { Codepoint, Predicate } from './types';\n\nexport type PackedBlocks = { names: (string | null)[]; lengths: number[] };\n\n// For Unicode 3.1 compatibility\nconst COMPATIBILITY_ALIASES: { [key: string]: string | undefined } = {\n\tGreekandCoptic: 'Greek',\n\tCombiningDiacriticalMarksforSymbols: 'CombiningMarksforSymbols',\n\tPrivateUseArea: 'PrivateUse',\n\t'SupplementaryPrivateUseArea-A': 'PrivateUse',\n\t'SupplementaryPrivateUseArea-B': 'PrivateUse',\n};\n\nexport function packBlocks(data: string): PackedBlocks {\n\tlet last = -1;\n\tconst names: (string | null)[] = [];\n\tconst lengths: number[] = [];\n\tdata.split('\\n').forEach((line) => {\n\t\tconst trimmed = line.trim();\n\t\tif (trimmed === '' || trimmed.startsWith('#')) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst [range, name] = trimmed.split(';');\n\t\tconst [startHex, endHex] = range.split('..');\n\t\tconst firstCodepoint = parseInt(startHex, 16);\n\t\tconst lastCodepoint = parseInt(endHex, 16);\n\t\tconst normalizedName = name.replace(/\\s/g, '');\n\t\tconst alias = COMPATIBILITY_ALIASES[normalizedName];\n\n\t\tif (firstCodepoint !== last + 1) {\n\t\t\t// Gap between blocks\n\t\t\tnames.push(null);\n\t\t\tlengths.push(firstCodepoint - last - 1);\n\t\t}\n\t\tnames.push(alias ? normalizedName + '|' + alias : normalizedName);\n\t\tlengths.push(lastCodepoint - firstCodepoint + 1);\n\t\tlast = lastCodepoint;\n\t});\n\n\treturn { names, lengths };\n}\n\nexport function unpackBlocks(\n\tnames: PackedBlocks['names'],\n\tlengths: PackedBlocks['lengths']\n): Map<string, Predicate> {\n\tconst predicateByNormalizedBlockId: Map<string, Predicate> = new Map();\n\tlet first: Codepoint = 0;\n\tnames.forEach((name: string | null, index: number) => {\n\t\tconst length = lengths[index];\n\t\tif (name !== null) {\n\t\t\tname.split('|').forEach((name) => {\n\t\t\t\tconst existing = predicateByNormalizedBlockId.get(name);\n\t\t\t\tconst predicate = charRange(first, first + length - 1);\n\t\t\t\tpredicateByNormalizedBlockId.set(\n\t\t\t\t\tname,\n\t\t\t\t\texisting ? union(existing, predicate) : predicate\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t\tfirst += length;\n\t});\n\treturn predicateByNormalizedBlockId;\n}\n","import {\n\tcomplete,\n\tcut,\n\tdelimited,\n\terror,\n\tfilter,\n\tfollowed,\n\tmap,\n\tnot,\n\tokWithValue,\n\toptional,\n\tor,\n\tParser,\n\tParseResult,\n\tpeek,\n\tplus,\n\tpreceded,\n\trecognize,\n\tstar,\n\tthen,\n\ttoken,\n} from 'prsc';\nimport { Atom, Branch, Piece, Quantifier, RegExp } from './ast';\nimport { INPUT_END_SENTINEL, INPUT_START_SENTINEL } from './basic-sets';\nimport {\n\tasCodepoint,\n\tcharRange as charRangePredicate,\n\tcomplement,\n\tdifference,\n\tmultiChar,\n\tsingleChar as singleCharPredicate,\n\tunicodeBlock,\n\tunicodeCategory,\n\tunion,\n\twildcard,\n} from './sets';\nimport { Codepoint, Predicate } from './types';\n\n// Tokens\n\nconst ASTERISK = token('*');\nconst BACKSLASH = token('\\\\');\nconst BRACE_OPEN = token('{');\nconst BRACE_CLOSE = token('}');\nconst BRACKET_OPEN = token('[');\nconst BRACKET_CLOSE = token(']');\nconst CARET = token('^');\nconst DOLLAR = token('$');\nconst COMMA = token(',');\nconst HYPHEN = token('-');\nconst PARENTHESIS_OPEN = token('(');\nconst PARENTHESIS_CLOSE = token(')');\nconst PERIOD = token('.');\nconst PIPE = token('|');\nconst PLUS = token('+');\nconst QUESTION_MARK = token('?');\nconst SUBTRACT_MARKER = token('-[');\n\nconst ZERO_CODE_POINT = asCodepoint('0');\n\nexport function generateParser(options: { language: string }): (input: string) => RegExp {\n\tfunction asSetOfCodepoints(chars: string): Set<Codepoint> {\n\t\treturn new Set(chars.split('').map((c) => asCodepoint(c)));\n\t}\n\n\tfunction codepoint(input: string, offset: number): ParseResult<Codepoint> {\n\t\tconst codepoint = input.codePointAt(offset);\n\t\tif (codepoint === undefined) {\n\t\t\treturn error(offset, ['any character']);\n\t\t}\n\t\treturn okWithValue(offset + String.fromCodePoint(codepoint).length, codepoint);\n\t}\n\n\t// Single Character Escape\n\n\tconst SingleCharEsc: Parser<Codepoint> =\n\t\toptions.language === 'xpath'\n\t\t\t? preceded(\n\t\t\t\t\tBACKSLASH,\n\t\t\t\t\tor([\n\t\t\t\t\t\tmap(token('n'), () => 0xa),\n\t\t\t\t\t\tmap(token('r'), () => 0xd),\n\t\t\t\t\t\tmap(token('t'), () => 0x9),\n\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\tor([\n\t\t\t\t\t\t\t\tBACKSLASH,\n\t\t\t\t\t\t\t\tPIPE,\n\t\t\t\t\t\t\t\tPERIOD,\n\t\t\t\t\t\t\t\tHYPHEN,\n\t\t\t\t\t\t\t\tCARET,\n\t\t\t\t\t\t\t\tQUESTION_MARK,\n\t\t\t\t\t\t\t\tASTERISK,\n\t\t\t\t\t\t\t\tPLUS,\n\t\t\t\t\t\t\t\tBRACE_OPEN,\n\t\t\t\t\t\t\t\tBRACE_CLOSE,\n\t\t\t\t\t\t\t\tDOLLAR,\n\t\t\t\t\t\t\t\tPARENTHESIS_OPEN,\n\t\t\t\t\t\t\t\tPARENTHESIS_CLOSE,\n\t\t\t\t\t\t\t\tBRACKET_OPEN,\n\t\t\t\t\t\t\t\tBRACKET_CLOSE,\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t(c) => asCodepoint(c)\n\t\t\t\t\t\t),\n\t\t\t\t\t])\n\t\t\t  )\n\t\t\t: preceded(\n\t\t\t\t\tBACKSLASH,\n\t\t\t\t\tor([\n\t\t\t\t\t\tmap(token('n'), () => 0xa),\n\t\t\t\t\t\tmap(token('r'), () => 0xd),\n\t\t\t\t\t\tmap(token('t'), () => 0x9),\n\t\t\t\t\t\tmap(\n\t\t\t\t\t\t\tor([\n\t\t\t\t\t\t\t\tBACKSLASH,\n\t\t\t\t\t\t\t\tPIPE,\n\t\t\t\t\t\t\t\tPERIOD,\n\t\t\t\t\t\t\t\tHYPHEN,\n\t\t\t\t\t\t\t\tCARET,\n\t\t\t\t\t\t\t\tQUESTION_MARK,\n\t\t\t\t\t\t\t\tASTERISK,\n\t\t\t\t\t\t\t\tPLUS,\n\t\t\t\t\t\t\t\tBRACE_OPEN,\n\t\t\t\t\t\t\t\tBRACE_CLOSE,\n\t\t\t\t\t\t\t\tPARENTHESIS_OPEN,\n\t\t\t\t\t\t\t\tPARENTHESIS_CLOSE,\n\t\t\t\t\t\t\t\tBRACKET_OPEN,\n\t\t\t\t\t\t\t\tBRACKET_CLOSE,\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t\t(c) => asCodepoint(c)\n\t\t\t\t\t\t),\n\t\t\t\t\t])\n\t\t\t  );\n\n\t// Categories\n\n\tfunction categoryIdentifier(primary: string, secondaries: string): Parser<Predicate> {\n\t\tconst secondaryChars = asSetOfCodepoints(secondaries);\n\t\treturn then(\n\t\t\ttoken(primary),\n\t\t\toptional(\n\t\t\t\tfilter(\n\t\t\t\t\tcodepoint,\n\t\t\t\t\t(codepoint) => secondaryChars.has(codepoint),\n\t\t\t\t\tsecondaries.split('')\n\t\t\t\t)\n\t\t\t),\n\t\t\t(p, s) => unicodeCategory(s === null ? p : p + String.fromCodePoint(s))\n\t\t);\n\t}\n\n\tconst Letters = categoryIdentifier('L', 'ultmo');\n\tconst Marks = categoryIdentifier('M', 'nce');\n\tconst Numbers = categoryIdentifier('N', 'dlo');\n\tconst Punctuation = categoryIdentifier('P', 'cdseifo');\n\tconst Separators = categoryIdentifier('Z', 'slp');\n\tconst Symbols = categoryIdentifier('S', 'mcko');\n\tconst Others = categoryIdentifier('C', 'cfon');\n\n\tconst IsCategory: Parser<Predicate> = or([\n\t\tLetters,\n\t\tMarks,\n\t\tNumbers,\n\t\tPunctuation,\n\t\tSeparators,\n\t\tSymbols,\n\t\tOthers,\n\t]);\n\n\t// Block Escape\n\n\tconst isBlockIdentifierChar: Predicate = [\n\t\tcharRangePredicate(asCodepoint('a'), asCodepoint('z')),\n\t\tcharRangePredicate(asCodepoint('A'), asCodepoint('Z')),\n\t\tcharRangePredicate(asCodepoint('0'), asCodepoint('9')),\n\t\tsingleCharPredicate(0x2d),\n\t].reduce(union);\n\n\tconst IsBlock: Parser<Predicate> = map(\n\t\tpreceded(\n\t\t\ttoken('Is'),\n\t\t\trecognize(plus(filter(codepoint, isBlockIdentifierChar, ['block identifier'])))\n\t\t),\n\t\t(identifier) => unicodeBlock(identifier, options.language !== 'xpath')\n\t);\n\n\t// Category Escape\n\n\tconst charProp: Parser<Predicate> = or([IsCategory, IsBlock]);\n\n\tconst catEsc: Parser<Predicate> = delimited(token('\\\\p{'), charProp, BRACE_CLOSE, true);\n\n\tconst complEsc: Parser<Predicate> = map(\n\t\tdelimited(token('\\\\P{'), charProp, BRACE_CLOSE, true),\n\t\tcomplement\n\t);\n\n\t// Multi-Character Escape\n\n\tconst MultiCharEsc: Parser<Predicate> = preceded(\n\t\tBACKSLASH,\n\t\tmap(\n\t\t\tor('sSiIcCdDwW'.split('').map((c) => token(c))) as Parser<keyof typeof multiChar>,\n\t\t\t(c) => multiChar[c]\n\t\t)\n\t);\n\n\tconst WildcardEsc: Parser<Predicate> = map(PERIOD, () => wildcard);\n\n\t// Character Class Escape\n\n\tconst charClassEsc: Parser<Predicate> = or([MultiCharEsc, catEsc, complEsc]);\n\n\t// Single Unescaped Character\n\n\tconst notSingleCharNoEsc = asSetOfCodepoints('\\\\[]');\n\n\tconst SingleCharNoEsc: Parser<Codepoint> = filter(\n\t\tcodepoint,\n\t\t(codepoint) => !notSingleCharNoEsc.has(codepoint),\n\t\t['unescaped character']\n\t);\n\n\tconst singleChar: Parser<Codepoint> = or([SingleCharEsc, SingleCharNoEsc]);\n\n\t// Character Range\n\n\tconst singleCharHyphenAsNull: Parser<Codepoint | null> = or([\n\t\tmap(HYPHEN, () => null),\n\t\tsingleChar,\n\t]);\n\n\tconst charRange: Parser<Predicate> = then(\n\t\tsingleCharHyphenAsNull,\n\t\tpreceded(HYPHEN, singleCharHyphenAsNull),\n\t\tcharRangePredicate\n\t);\n\n\t// Character Group Part\n\n\tfunction cons<T>(first: T, rest: T[] | null) {\n\t\treturn [first].concat(rest || []);\n\t}\n\n\tconst assertEndOfCharGroup: Parser<null> = map(\n\t\tpeek(or([BRACKET_CLOSE, SUBTRACT_MARKER])),\n\t\t() => null\n\t);\n\n\tconst hyphenCodepoint = asCodepoint('-');\n\tconst singleCharHyphenWithHyphenRules: Parser<Codepoint> = map(\n\t\tfollowed(followed(HYPHEN, not(BRACKET_OPEN, ['not ['])), assertEndOfCharGroup),\n\t\t() => hyphenCodepoint\n\t);\n\n\tconst singleCharWithHyphenRules: Parser<Codepoint> = or([\n\t\tsingleCharHyphenWithHyphenRules,\n\t\tpreceded(not(HYPHEN, ['not -']), singleChar),\n\t]);\n\n\tconst charGroupPartsWithHyphenRules: Parser<Predicate[]> = or([\n\t\tthen(\n\t\t\tmap(singleCharWithHyphenRules, singleCharPredicate),\n\t\t\tor([charGroupPartsWithHyphenRulesIndirect, assertEndOfCharGroup]),\n\t\t\tcons\n\t\t),\n\t\tthen(\n\t\t\tor([charRange, charClassEsc]),\n\t\t\tor([charGroupPartsIndirect, assertEndOfCharGroup]),\n\t\t\tcons\n\t\t),\n\t]);\n\n\tfunction charGroupPartsWithHyphenRulesIndirect(\n\t\tinput: string,\n\t\toffset: number\n\t): ParseResult<Predicate[]> {\n\t\treturn charGroupPartsWithHyphenRules(input, offset);\n\t}\n\n\tconst charGroupParts: Parser<Predicate[]> = or([\n\t\tthen(\n\t\t\tmap(singleChar, singleCharPredicate),\n\t\t\tor([charGroupPartsWithHyphenRules, assertEndOfCharGroup]),\n\t\t\tcons\n\t\t),\n\t\tthen(\n\t\t\tor([charRange, charClassEsc]),\n\t\t\tor([charGroupPartsIndirect, assertEndOfCharGroup]),\n\t\t\tcons\n\t\t),\n\t]);\n\n\tfunction charGroupPartsIndirect(input: string, offset: number): ParseResult<Predicate[]> {\n\t\treturn charGroupParts(input, offset);\n\t}\n\n\t// Positive Character Group\n\n\tconst posCharGroup: Parser<Predicate> = map(charGroupParts, (parts) => parts.reduce(union));\n\n\t// Negative Character Group\n\n\tconst negCharGroup: Parser<Predicate> = map(preceded(CARET, posCharGroup), complement);\n\n\t// Character Group\n\n\tconst charGroup: Parser<Predicate> = then(\n\t\tor([preceded(not(CARET, ['not ^']), posCharGroup), negCharGroup]),\n\t\toptional(preceded(HYPHEN, charClassExprIndirect)),\n\t\tdifference\n\t);\n\n\t// Character Class Expression\n\n\tconst charClassExpr: Parser<Predicate> = delimited(\n\t\tBRACKET_OPEN,\n\t\tcharGroup,\n\t\tBRACKET_CLOSE,\n\t\ttrue\n\t);\n\n\tfunction charClassExprIndirect(input: string, offset: number): ParseResult<Predicate> {\n\t\treturn charClassExpr(input, offset);\n\t}\n\n\t// Character Class\n\n\tconst charClass: Parser<Predicate> =\n\t\toptions.language === 'xpath'\n\t\t\t? or([\n\t\t\t\t\tmap(SingleCharEsc, singleCharPredicate),\n\t\t\t\t\tcharClassEsc,\n\t\t\t\t\tcharClassExpr,\n\t\t\t\t\tWildcardEsc,\n\t\t\t\t\tmap(CARET, () => (c: Codepoint) => c === INPUT_START_SENTINEL),\n\t\t\t\t\tmap(DOLLAR, () => (c: Codepoint) => c === INPUT_END_SENTINEL),\n\t\t\t  ])\n\t\t\t: or([\n\t\t\t\t\tmap(SingleCharEsc, singleCharPredicate),\n\t\t\t\t\tcharClassEsc,\n\t\t\t\t\tcharClassExpr,\n\t\t\t\t\tWildcardEsc,\n\t\t\t  ]);\n\n\t// Normal Character\n\n\tconst metachars =\n\t\toptions.language === 'xpath'\n\t\t\t? asSetOfCodepoints('.\\\\?*+{}()|^$[]')\n\t\t\t: asSetOfCodepoints('.\\\\?*+{}()|[]');\n\tconst NormalChar: Parser<Codepoint> = filter(\n\t\tcodepoint,\n\t\t(codepoint) => !metachars.has(codepoint),\n\t\t['NormalChar']\n\t);\n\n\t// BackReference (XPath only)\n\tconst backReference: Parser<never> = map(\n\t\tpreceded(\n\t\t\tBACKSLASH,\n\t\t\tthen(\n\t\t\t\tmap(\n\t\t\t\t\tfilter(codepoint, charRangePredicate(asCodepoint('1'), asCodepoint('9')), [\n\t\t\t\t\t\t'digit',\n\t\t\t\t\t]),\n\t\t\t\t\t(codepoint) => codepoint - ZERO_CODE_POINT\n\t\t\t\t),\n\t\t\t\tstar(\n\t\t\t\t\tmap(\n\t\t\t\t\t\tfilter(codepoint, charRangePredicate(ZERO_CODE_POINT, asCodepoint('9')), [\n\t\t\t\t\t\t\t'digit',\n\t\t\t\t\t\t]),\n\t\t\t\t\t\t(codepoint) => codepoint - ZERO_CODE_POINT\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\t(firstDigit, restDigits) => {\n\t\t\t\t\trestDigits.reduce((sum, digit) => sum * 10 + digit, firstDigit);\n\t\t\t\t}\n\t\t\t)\n\t\t),\n\t\t(_backReferenceNumber) => {\n\t\t\tthrow new Error('Backreferences in XPath patterns are not yet implemented.');\n\t\t}\n\t);\n\n\t// Atom\n\n\tconst atom: Parser<Atom> =\n\t\toptions.language === 'xpath'\n\t\t\t? or<Atom>([\n\t\t\t\t\tmap(NormalChar, (codepoint) => ({\n\t\t\t\t\t\tkind: 'predicate',\n\t\t\t\t\t\tvalue: singleCharPredicate(codepoint),\n\t\t\t\t\t})),\n\t\t\t\t\tmap(charClass, (predicate) => ({ kind: 'predicate', value: predicate })),\n\t\t\t\t\tmap(\n\t\t\t\t\t\tdelimited(\n\t\t\t\t\t\t\tPARENTHESIS_OPEN,\n\t\t\t\t\t\t\tpreceded(optional(token('?:')), regexpIndirect),\n\t\t\t\t\t\t\tPARENTHESIS_CLOSE,\n\t\t\t\t\t\t\ttrue\n\t\t\t\t\t\t),\n\t\t\t\t\t\t(regexp) => ({\n\t\t\t\t\t\t\tkind: 'regexp',\n\t\t\t\t\t\t\tvalue: regexp,\n\t\t\t\t\t\t})\n\t\t\t\t\t),\n\t\t\t\t\tbackReference,\n\t\t\t  ])\n\t\t\t: or<Atom>([\n\t\t\t\t\tmap(NormalChar, (codepoint) => ({\n\t\t\t\t\t\tkind: 'predicate',\n\t\t\t\t\t\tvalue: singleCharPredicate(codepoint),\n\t\t\t\t\t})),\n\t\t\t\t\tmap(charClass, (predicate) => ({ kind: 'predicate', value: predicate })),\n\t\t\t\t\tmap(\n\t\t\t\t\t\tdelimited(PARENTHESIS_OPEN, regexpIndirect, PARENTHESIS_CLOSE, true),\n\t\t\t\t\t\t(regexp) => ({\n\t\t\t\t\t\t\tkind: 'regexp',\n\t\t\t\t\t\t\tvalue: regexp,\n\t\t\t\t\t\t})\n\t\t\t\t\t),\n\t\t\t  ]);\n\n\t// Quantifier\n\n\tconst isDigit = charRangePredicate(ZERO_CODE_POINT, asCodepoint('9'));\n\tconst QuantExact: Parser<number> = map(\n\t\tplus(\n\t\t\tmap(filter(codepoint, isDigit, ['digit']), (codepoint) => codepoint - ZERO_CODE_POINT)\n\t\t),\n\t\t(digits) => digits.reduce((num, digit) => num * 10 + digit)\n\t);\n\n\tconst quantRange: Parser<Quantifier> = then(\n\t\tQuantExact,\n\t\tpreceded(COMMA, QuantExact),\n\t\t(min, max) => {\n\t\t\tif (max < min) {\n\t\t\t\tthrow new Error('quantifier range is in the wrong order');\n\t\t\t}\n\t\t\treturn { min, max };\n\t\t}\n\t);\n\n\tconst quantMin: Parser<Quantifier> = then(QuantExact, COMMA, (min) => ({ min, max: null }));\n\n\tconst quantity: Parser<Quantifier> = or([\n\t\tquantRange,\n\t\tquantMin,\n\t\tmap(QuantExact, (q) => ({ min: q, max: q })),\n\t]);\n\n\tconst quantifier: Parser<Quantifier> =\n\t\toptions.language === 'xpath'\n\t\t\t? then(\n\t\t\t\t\tor<Quantifier>([\n\t\t\t\t\t\tmap(QUESTION_MARK, () => ({ min: 0, max: 1 })),\n\t\t\t\t\t\tmap(ASTERISK, () => ({ min: 0, max: null })),\n\t\t\t\t\t\tmap(PLUS, () => ({ min: 1, max: null })),\n\t\t\t\t\t\tdelimited(BRACE_OPEN, quantity, BRACE_CLOSE, true),\n\t\t\t\t\t]),\n\t\t\t\t\toptional(QUESTION_MARK),\n\t\t\t\t\t(quantifier, _isReluctant) => quantifier\n\t\t\t  )\n\t\t\t: or<Quantifier>([\n\t\t\t\t\tmap(QUESTION_MARK, () => ({ min: 0, max: 1 })),\n\t\t\t\t\tmap(ASTERISK, () => ({ min: 0, max: null })),\n\t\t\t\t\tmap(PLUS, () => ({ min: 1, max: null })),\n\t\t\t\t\tdelimited(BRACE_OPEN, quantity, BRACE_CLOSE, true),\n\t\t\t  ]);\n\n\t// Piece\n\n\tconst piece: Parser<Piece> = then(\n\t\tatom,\n\t\tmap(optional(quantifier), (q) => (q === null ? { min: 1, max: 1 } : q)),\n\t\t(a, q) => [a, q]\n\t);\n\n\t// Branch\n\n\tconst branch: Parser<Branch> = star(piece);\n\n\t// Regular Expression - with wrapper because of recursion\n\n\tconst regexp: Parser<RegExp> = then(branch, star(preceded(PIPE, cut(branch))), (b, bs) =>\n\t\t[b].concat(bs)\n\t);\n\n\tfunction regexpIndirect(input: string, offset: number): ParseResult<RegExp> {\n\t\treturn regexp(input, offset);\n\t}\n\n\tfunction throwParseError(input: string, offset: number, expected: string[]): never {\n\t\tconst quoted = expected.map((str) => `\"${str}\"`);\n\t\tthrow new Error(\n\t\t\t`Error parsing pattern \"${input}\" at offset ${offset}: expected ${\n\t\t\t\tquoted.length > 1 ? 'one of ' + quoted.join(', ') : quoted[0]\n\t\t\t} but found \"${input.slice(offset, offset + 1)}\"`\n\t\t);\n\t}\n\n\tconst completeRegexp: Parser<RegExp> = complete(regexp);\n\n\treturn function parse(input: string): RegExp {\n\t\tlet res: ParseResult<RegExp>;\n\t\ttry {\n\t\t\tres = completeRegexp(input, 0);\n\t\t} catch (error) {\n\t\t\t// Generic error\n\t\t\tthrow new Error(`Error parsing pattern \"${input}\": ${error.message}`);\n\t\t}\n\t\tif (!res.success) {\n\t\t\treturn throwParseError(input, res.offset, res.expected);\n\t\t}\n\n\t\treturn res.value;\n\t};\n}\n","import { compileVM } from 'whynot';\nimport { INPUT_END_SENTINEL, INPUT_START_SENTINEL } from './basic-sets';\nimport { compileRegExp } from './compiler';\nimport { generateParser } from './parser';\n\nfunction toCodePoints(str: string): number[] {\n\treturn [...str].map((c) => c.codePointAt(0)!);\n}\n\n/**\n * A function used to validate strings against the pattern it represents. Accepts a single string\n * and returns a boolean indicating whether it matches the pattern.\n *\n * @public\n */\nexport type MatchFn = (str: string) => boolean;\n\n/**\n * Options to control pattern compilation.\n *\n * Currently, only a language option is supported, defaulting to 'xsd'. Set this to 'xpath' to\n * compile the pattern with XPath syntax and semantics. Note that not all XPath-specific features\n * are currently supported. See https://github.com/bwrrp/xspattern.js/issues/9 for details.\n *\n * @public\n */\nexport type Options = {\n\tlanguage: 'xsd' | 'xpath';\n};\n\n/**\n * Compiles the given pattern into a matching function. The returned function accepts a single\n * string and returns true iff the pattern matches it.\n *\n * @public\n *\n * @param pattern - Pattern to compile\n * @param options - Additional options for the compiler\n *\n * @returns a matcher function for the given pattern\n */\nexport function compile(pattern: string, options: Options = { language: 'xsd' }): MatchFn {\n\tconst ast = generateParser(options)(pattern);\n\n\tconst vm = compileVM<number>((assembler) => {\n\t\tcompileRegExp(assembler, ast, options.language === 'xpath');\n\t\tassembler.accept();\n\t});\n\n\treturn function match(str: string): boolean {\n\t\tconst codepoints =\n\t\t\toptions.language === 'xpath'\n\t\t\t\t? [INPUT_START_SENTINEL, ...toCodePoints(str), INPUT_END_SENTINEL]\n\t\t\t\t: toCodePoints(str);\n\t\treturn vm.execute(codepoints).success;\n\t};\n}\n"],"names":["singleChar","expected","codepoint","charRange","first","last","Error","everything","_codepoint","nothing","union","next","compileAtom","assembler","atom","kind","test","value","compileRegExp","compileBranch","branch","forEach","piece","atomAst","min","max","i","fork","jump","data","push","program","length","start","compilePiece","regExp","matchSubstring","joins","join","beforeFork","forkForEnd","okWithValue","offset","success","ok","error","fatal","token","input","offsetAfter","slice","map","parser","res","filter","or","parsers","lastError","concat","optional","star","ts","nextOffset","then","parser1","parser2","r1","r2","plus","v","vs","x","y","second","preceded","before","followed","after","delimited","open","inner","close","cutAfterOpen","cut","not","end","CATEGORIES","numberByBase64","asCodepoint","char","codePointAt","split","c","sentinel","complement","predicate","difference","except","predicateByNormalizedBlockId","names","lengths","Map","name","index","existing","get","set","unpackBlocks","predicateByCategory","packed","encodedMapping","partsByCatIndex","encodedCatIndex","catIndex","actualCatIndex","parts","partsByPrefix","category","reduce","prefix","charAt","unpackCategories","whitespace","nameStartChar","nameChar","digit","notDigit","wordChar","notWordChar","wildcard","multiChar","s","S","I","C","d","D","w","W","ASTERISK","BACKSLASH","BRACE_OPEN","BRACE_CLOSE","BRACKET_OPEN","BRACKET_CLOSE","CARET","DOLLAR","COMMA","HYPHEN","PARENTHESIS_OPEN","PARENTHESIS_CLOSE","PERIOD","PIPE","PLUS","QUESTION_MARK","SUBTRACT_MARKER","ZERO_CODE_POINT","generateParser","options","asSetOfCodepoints","chars","Set","undefined","String","fromCodePoint","SingleCharEsc","language","categoryIdentifier","primary","secondaries","secondaryChars","has","p","identifier","unicodeCategory","IsCategory","isBlockIdentifierChar","charRangePredicate","singleCharPredicate","charProp","recognize","acceptUnknownBlocks","unicodeBlock","catEsc","complEsc","MultiCharEsc","WildcardEsc","charClassEsc","notSingleCharNoEsc","singleCharHyphenAsNull","cons","rest","assertEndOfCharGroup","peek","hyphenCodepoint","singleCharWithHyphenRules","charGroupPartsWithHyphenRules","charGroupPartsIndirect","charGroupParts","posCharGroup","negCharGroup","charGroup","charClassExpr","charClass","metachars","NormalChar","backReference","firstDigit","restDigits","sum","_backReferenceNumber","regexpIndirect","regexp","QuantExact","digits","num","quantity","q","quantifier","_isReluctant","a","b","bs","completeRegexp","complete","message","quoted","str","throwParseError","toCodePoints","pattern","ast","vm","compileVM","accept","codepoints","execute"],"mappings":"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"}