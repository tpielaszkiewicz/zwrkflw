{"version":3,"file":"whynot.umd.js","sources":["../src/Assembler.ts","../src/ProgramInfo.ts","../src/Result.ts","../src/Generation.ts","../src/FromBuffer.ts","../src/LazySet.ts","../src/Trace.ts","../src/Tracer.ts","../src/Traces.ts","../src/Scheduler.ts","../src/VM.ts","../src/index.ts"],"sourcesContent":["import { Instruction, FailFunc, TestFunc, RecordFunc, Operation } from './Instruction';\r\n\r\nfunction addInstruction<TInput, TRecord, TOptions>(\r\n\tprogram: Instruction<TInput, TRecord, TOptions>[],\r\n\top: Operation,\r\n\tfunc: FailFunc<TOptions> | TestFunc<TInput, TOptions> | RecordFunc<TRecord, TOptions> | null,\r\n\tdata: any\r\n): Instruction<TInput, TRecord, TOptions> {\r\n\tconst instruction = { op, func, data };\r\n\tprogram.push(instruction);\r\n\treturn instruction;\r\n}\r\n\r\nfunction defaultRecorder<TRecord>(data: TRecord, _inputIndex: number): TRecord {\r\n\treturn data;\r\n}\r\n\r\n/**\r\n * The Assembler is used to generate a whynot program by appending instructions.\r\n *\r\n * @public\r\n */\r\nexport default class Assembler<TInput, TRecord, TOptions = void> {\r\n\treadonly program: Instruction<TInput, TRecord, TOptions>[] = [];\r\n\r\n\t/**\r\n\t * The 'test' instruction validates and consumes an input item.\r\n\t *\r\n\t * If the matcher returns true, execution continues in the next Generation, otherwise execution\r\n\t * of the current Thread ends.\r\n\t *\r\n\t * @param matcher - Callback to invoke for the input, should return true to accept, false to\r\n\t *                  reject.\r\n\t * @param data    - Data to be passed to the matcher callback. Defaults to null.\r\n\t *\r\n\t * @returns The new instruction\r\n\t */\r\n\ttest(matcher: TestFunc<TInput, TOptions>, data?: any): Instruction<TInput, TRecord, TOptions> {\r\n\t\treturn addInstruction(\r\n\t\t\tthis.program,\r\n\t\t\tOperation.TEST,\r\n\t\t\tmatcher,\r\n\t\t\tdata === undefined ? null : data\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * The 'jump' instruction continues execution in the current Generation at any number of other\r\n\t * locations. A new Thread will be spawned for each target.\r\n\t *\r\n\t * @param targets - Program counters at which to continue execution\r\n\t *\r\n\t * @returns The new instruction\r\n\t */\r\n\tjump(targets: number[]): Instruction<TInput, TRecord, TOptions> {\r\n\t\treturn addInstruction(this.program, Operation.JUMP, null, targets);\r\n\t}\r\n\r\n\t/**\r\n\t * The 'record' instruction adds a custom record to the current Thread's trace and resumes\r\n\t * execution at the next instruction in the same Generation.\r\n\t *\r\n\t * @param data     - Data to record\r\n\t * @param recorder - Callback to generate the record based on data and the current input\r\n\t *                   position. Defaults to recording data.\r\n\t *\r\n\t * @returns The new instruction\r\n\t */\r\n\trecord<TRecorder>(\r\n\t\tdata: TRecorder extends undefined ? TRecord : any,\r\n\t\trecorder?: RecordFunc<TRecord, TOptions>\r\n\t): Instruction<TInput, TRecord, TOptions> {\r\n\t\treturn addInstruction(\r\n\t\t\tthis.program,\r\n\t\t\tOperation.RECORD,\r\n\t\t\trecorder === undefined ? defaultRecorder : recorder,\r\n\t\t\tdata\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * The 'bad' instruction permanently lowers the priority of all threads originating in the\r\n\t * current one.\r\n\t *\r\n\t * @param cost - Amount to increase badness with. Defaults to 1.\r\n\t *\r\n\t * @returns The new instruction\r\n\t */\r\n\tbad(cost: number = 1): Instruction<TInput, TRecord, TOptions> {\r\n\t\treturn addInstruction(this.program, Operation.BAD, null, cost);\r\n\t}\r\n\r\n\t/**\r\n\t * The 'accept' instruction causes the VM to yield the current Thread's Trace upon completion,\r\n\t * provided all input has been consumed. Otherwise, the Thread ends.\r\n\t *\r\n\t * @returns The new instruction\r\n\t */\r\n\taccept(): Instruction<TInput, TRecord, TOptions> {\r\n\t\treturn addInstruction(this.program, Operation.ACCEPT, null, null);\r\n\t}\r\n\r\n\t/**\r\n\t * The 'fail' instruction ends the current Thread.\r\n\t *\r\n\t * @param predicate - Optional callback to make the fail conditional, if this returns true the\r\n\t *                    thread will end, otherwise it will continue.\r\n\t *\r\n\t * @returns The new instruction\r\n\t */\r\n\tfail(predicate?: FailFunc<TOptions>): Instruction<TInput, TRecord, TOptions> {\r\n\t\treturn addInstruction(this.program, Operation.FAIL, predicate || null, null);\r\n\t}\r\n}\r\n","import { Instruction, Operation } from './Instruction';\r\n\r\n/**\r\n * Computes information about a given program, used to allocate enough space in the data structures\r\n * required to run that program.\r\n */\r\nexport default class ProgramInfo {\r\n\tprivate constructor(\r\n\t\tpublic readonly programLength: number,\r\n\t\tpublic readonly maxFromByPc: number[],\r\n\t\tpublic readonly maxSurvivorFromByPc: number[]\r\n\t) {}\r\n\r\n\t/**\r\n\t * Creates an instance with information for the given program.\r\n\t *\r\n\t * @param program - The program for which to construct the instance.\r\n\t */\r\n\tpublic static fromProgram<TInput, TRecord, TOptions>(\r\n\t\tprogram: Instruction<TInput, TRecord, TOptions>[]\r\n\t): ProgramInfo {\r\n\t\tconst programLength = program.length;\r\n\r\n\t\t// Determine maximum number of incoming paths per instructon\r\n\t\tconst maxFromByPc: number[] = [];\r\n\t\tconst maxSurvivorFromByPc: number[] = [];\r\n\t\tprogram.forEach(_ => {\r\n\t\t\tmaxFromByPc.push(0);\r\n\t\t\tmaxSurvivorFromByPc.push(0);\r\n\t\t});\r\n\t\tprogram.forEach((instruction, pc) => {\r\n\t\t\tswitch (instruction.op) {\r\n\t\t\t\tcase Operation.FAIL:\r\n\t\t\t\t\tif (instruction.func === null) {\r\n\t\t\t\t\t\t// Unconditional fail, threads will never continue past this instruction\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (pc + 1 >= programLength) {\r\n\t\t\t\t\t\tthrow new Error('Invalid program: program could run past end');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmaxFromByPc[pc + 1] += 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Operation.BAD:\r\n\t\t\t\tcase Operation.RECORD:\r\n\t\t\t\t\tif (pc + 1 >= programLength) {\r\n\t\t\t\t\t\tthrow new Error('Invalid program: program could run past end');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmaxFromByPc[pc + 1] += 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Operation.JUMP:\r\n\t\t\t\t\tconst targets = instruction.data as number[];\r\n\t\t\t\t\ttargets.forEach(targetPc => {\r\n\t\t\t\t\t\tif (targetPc < 0 || targetPc >= programLength) {\r\n\t\t\t\t\t\t\tthrow new Error('Invalid program: program could run past end');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tmaxFromByPc[targetPc] += 1;\r\n\t\t\t\t\t});\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Operation.TEST:\r\n\t\t\t\t\tif (pc + 1 >= programLength) {\r\n\t\t\t\t\t\tthrow new Error('Invalid program: program could run past end');\r\n\t\t\t\t\t}\r\n\t\t\t\t\tmaxSurvivorFromByPc[pc + 1] += 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase Operation.ACCEPT:\r\n\t\t\t\t\tmaxSurvivorFromByPc[pc] += 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn new ProgramInfo(programLength, maxFromByPc, maxSurvivorFromByPc);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a stub ProgramInfo with incoming info maxed out to ensure enough space is allocated\r\n\t * in FromBuffers for simulating any program of the given length.\r\n\t *\r\n\t * For testing only.\r\n\t *\r\n\t * @param programLength The length of the supposed program\r\n\t */\r\n\tpublic static createStub(programLength: number): ProgramInfo {\r\n\t\tconst maxFromByPc: number[] = [];\r\n\t\tconst maxSurvivorFromByPc: number[] = [];\r\n\t\tfor (let i = 0; i < programLength; ++i) {\r\n\t\t\tmaxFromByPc.push(programLength);\r\n\t\t\tmaxSurvivorFromByPc.push(programLength);\r\n\t\t}\r\n\r\n\t\treturn new ProgramInfo(programLength, maxFromByPc, maxSurvivorFromByPc);\r\n\t}\r\n}\r\n","import Trace from './Trace';\r\n\r\n/**\r\n * The result of running a VM on an input sequence.\r\n *\r\n * @public\r\n */\r\nexport default class Result<TRecord> {\r\n\t/**\r\n\t * Whether the input was accepted by the program.\r\n\t */\r\n\tpublic readonly success: boolean;\r\n\r\n\tconstructor(\r\n\t\t/**\r\n\t\t * The traces that lead to input being accepted, or an empty array if the input was not\r\n\t\t * accepted by the program.\r\n\t\t */\r\n\t\tpublic readonly acceptingTraces: Trace<TRecord>[]\r\n\t) {\r\n\t\tthis.success = acceptingTraces.length > 0;\r\n\t}\r\n}\r\n","/**\r\n * Perform a binary search to find the index of the first thread with lower badness, within the\r\n * given bounds.\r\n *\r\n * This can then be the index at which to insert a new pc while preserving ordering according to\r\n * badness.\r\n *\r\n * @param pcs         - The array of scheduled pcs to search.\r\n * @param badnessByPc - Provides the current badness value for each pc in the array.\r\n * @param badness     - The badness to compare to (i.e., the value for the pc to be inserted).\r\n * @param first       - First index in pcs to consider.\r\n * @param length      - The length of the sub-array of pcs to consider. Also the highest index that\r\n *                      can be returned by this function.\r\n */\r\nfunction findInsertionIndex(\r\n\tpcs: Uint16Array,\r\n\tbadnessByPc: Uint8Array,\r\n\tbadness: number,\r\n\tfirst: number,\r\n\tlength: number\r\n): number {\r\n\tlet low = first;\r\n\tlet high = length;\r\n\twhile (low < high) {\r\n\t\t// Use zero-filling shift as integer division\r\n\t\tconst mid = (low + high) >>> 1;\r\n\t\t// Compare to mid point, preferring right in case of equality\r\n\t\tif (badness < badnessByPc[pcs[mid]]) {\r\n\t\t\t// Thread goes in lower half\r\n\t\t\thigh = mid;\r\n\t\t} else {\r\n\t\t\t// Thread goes in upper half\r\n\t\t\tlow = mid + 1;\r\n\t\t}\r\n\t}\r\n\r\n\treturn low;\r\n}\r\n\r\n/**\r\n * The highest supported badness value. Attempts to set badness higher than this are clamped to this\r\n * value.\r\n */\r\nconst MAX_BADNESS = 255;\r\n\r\n/**\r\n * Schedules threads within a Generation according to their associated badness.\r\n */\r\nexport default class Generation {\r\n\t// Program counters of scheduled threads in order of execution\r\n\tprivate readonly _scheduledPcs: Uint16Array;\r\n\tprivate _numScheduledPcs: number = 0;\r\n\r\n\t// Index of the next thread to execute in the array above\r\n\tprivate _nextThread: number = 0;\r\n\r\n\t// Badness values for scheduled threads by program counter\r\n\tprivate readonly _badnessByPc: Uint8Array;\r\n\r\n\tconstructor(programLength: number) {\r\n\t\tthis._scheduledPcs = new Uint16Array(programLength);\r\n\t\tthis._badnessByPc = new Uint8Array(programLength);\r\n\t}\r\n\r\n\tpublic getBadness(pc: number): number {\r\n\t\treturn this._badnessByPc[pc];\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a new entry for pc to the scheduled pcs.\r\n\t *\r\n\t * The caller should ensure that pc is not already scheduled.\r\n\t *\r\n\t * @param pc      The pc to add\r\n\t * @param badness The badness to associate with pc\r\n\t */\r\n\tpublic add(pc: number, badness: number): void {\r\n\t\tthis._badnessByPc[pc] = badness > MAX_BADNESS ? MAX_BADNESS : badness;\r\n\t\tconst insertionIndex = findInsertionIndex(\r\n\t\t\tthis._scheduledPcs,\r\n\t\t\tthis._badnessByPc,\r\n\t\t\tbadness,\r\n\t\t\tthis._nextThread,\r\n\t\t\tthis._numScheduledPcs\r\n\t\t);\r\n\t\tthis._scheduledPcs.copyWithin(insertionIndex + 1, insertionIndex, this._numScheduledPcs);\r\n\t\tthis._scheduledPcs[insertionIndex] = pc;\r\n\t\tthis._numScheduledPcs += 1;\r\n\t}\r\n\r\n\t/**\r\n\t * Reschedule an already scheduled pc according to a new badness value.\r\n\t *\r\n\t * The caller should ensure this is only called for pcs that have already been scheduled.\r\n\t *\r\n\t * @param pc      The pc to reschedule\r\n\t * @param badness The new badness to associate with pc\r\n\t */\r\n\tpublic reschedule(pc: number, badness: number): void {\r\n\t\tconst maxBadness = Math.max(\r\n\t\t\tthis._badnessByPc[pc],\r\n\t\t\tbadness > MAX_BADNESS ? MAX_BADNESS : badness\r\n\t\t);\r\n\t\tif (this._badnessByPc[pc] !== maxBadness) {\r\n\t\t\t// Remove any existing unexecuted thread in order to reschedule it\r\n\t\t\tconst existingThreadIndex = this._scheduledPcs.indexOf(pc, this._nextThread);\r\n\t\t\tif (existingThreadIndex < 0 || existingThreadIndex >= this._numScheduledPcs) {\r\n\t\t\t\tthis._badnessByPc[pc] = maxBadness;\r\n\t\t\t\t// Thread has already been executed, do not reschedule\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Remove and re-schedule the thread\r\n\t\t\t// TODO: use a single copyWithin call instead of two\r\n\t\t\tthis._scheduledPcs.copyWithin(\r\n\t\t\t\texistingThreadIndex,\r\n\t\t\t\texistingThreadIndex + 1,\r\n\t\t\t\tthis._numScheduledPcs\r\n\t\t\t);\r\n\t\t\tthis._numScheduledPcs -= 1;\r\n\t\t\tthis.add(pc, maxBadness);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get the next scheduled pc.\r\n\t *\r\n\t * This pc will have the lowest badness among all currently scheduled pcs.\r\n\t *\r\n\t * Returns null if there are no more scheduled pcs in this Generation.\r\n\t */\r\n\tpublic getNextPc(): number | null {\r\n\t\tif (this._nextThread >= this._numScheduledPcs) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\treturn this._scheduledPcs[this._nextThread++];\r\n\t}\r\n\r\n\t/**\r\n\t * Clear all scheduled pcs and badness values so the Generation can be reused.\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis._numScheduledPcs = 0;\r\n\t\tthis._nextThread = 0;\r\n\t\tthis._badnessByPc.fill(0);\r\n\t}\r\n}\r\n","/**\r\n * The FromBuffer efficiently stores an \"array of arrays\", which for each instruction index (pc or\r\n * \"program counter\") tracks the pcs from which steps arrived at that instruction.\r\n *\r\n * To prevent allocation during the runtime of the whynot program, this data is stored in a single\r\n * Uint16Array. This buffer is sized to be able to hold for each pc the maximum number of incoming\r\n * steps, as derived from the program by ProgramInfo, as well as the current lengths of the\r\n * sub-array for each pc. The lower programLength entries contain these lengts, while the _mapping\r\n * array provides the offset at which each pcs data starts.\r\n */\r\nexport default class FromBuffer {\r\n\tprivate readonly _buffer: Uint16Array;\r\n\tprivate readonly _mapping: number[] = [];\r\n\r\n\t/**\r\n\t * @param maxFromByPc - The maximum number of entries to reserve for each pc.\r\n\t */\r\n\tconstructor(maxFromByPc: number[]) {\r\n\t\tlet offset = maxFromByPc.length;\r\n\t\tmaxFromByPc.forEach(max => {\r\n\t\t\tthis._mapping.push(max > 0 ? offset : -1);\r\n\t\t\toffset += max;\r\n\t\t});\r\n\r\n\t\t// Allocate enough room for lengths and elements\r\n\t\tthis._buffer = new Uint16Array(offset);\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the buffer.\r\n\t *\r\n\t * This only resets the lengths, as that will make the data for each pc inaccessible.\r\n\t */\r\n\tpublic clear(): void {\r\n\t\tthis._buffer.fill(0, 0, this._mapping.length);\r\n\t}\r\n\r\n\t/**\r\n\t * Add an entry to the buffer.\r\n\t *\r\n\t * This method does not perform bounds checking, the caller should ensure no more entries are\r\n\t * added for each toPc than the maximum provided to the constructor.\r\n\t *\r\n\t * @param fromPc - The entry to add (the pc this step came from).\r\n\t * @param toPc   - The pc for which to add the entry.\r\n\t */\r\n\tpublic add(fromPc: number, toPc: number): void {\r\n\t\tconst length = this._buffer[toPc];\r\n\t\tconst offset = this._mapping[toPc];\r\n\t\tthis._buffer[toPc] += 1;\r\n\t\tthis._buffer[offset + length] = fromPc;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether any entries have been added for the given pc.\r\n\t *\r\n\t * @param toPc - The pc to check entries for.\r\n\t */\r\n\tpublic has(toPc: number): boolean {\r\n\t\tconst length = this._buffer[toPc];\r\n\t\treturn length > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates over the entries added for the given pc, (synchronously) invoking callback with the\r\n\t * value of each entry.\r\n\t *\r\n\t * @param toPc     - The entry whose values should be iterated over.\r\n\t * @param callback - Callback to invoke for each value.\r\n\t */\r\n\tpublic forEach(toPc: number, callback: (fromPc: number) => void): void {\r\n\t\tconst length = this._buffer[toPc];\r\n\t\tconst offset = this._mapping[toPc];\r\n\t\tfor (let i = offset; i < offset + length; ++i) {\r\n\t\t\tcallback(this._buffer[i]);\r\n\t\t}\r\n\t}\r\n}\r\n","/**\r\n * Represents a lazily-allocated Set-like datatype.\r\n *\r\n * Allocating actual sets during tracing is quite expensive, especially given that in the vast\r\n * majority of cases these sets will only consist of zero or one item. This simply represents those\r\n * cases as null or the item itself respectively, avoiding allocation until the set contains two or\r\n * more items.\r\n */\r\nexport type LazySet<T> = null | T | T[];\r\n\r\n/**\r\n * Returns the LazySet resulting from adding an item to the given LazySet.\r\n *\r\n * If item is already in set, always returns set.\r\n *\r\n * @param set            - The LazySet to add the item to\r\n * @param item           - The item to add\r\n * @param setIsImmutable - If left at false, when set is an array, item is pushed into the existing\r\n *                         array. If set to true, a new array will be allocated instead. This can be\r\n *                         used to prevent mutation of an existing set if you need to keep the\r\n *                         original value.\r\n */\r\nexport function addToLazySet<T>(\r\n\tset: LazySet<T>,\r\n\titem: T,\r\n\tsetIsImmutable: boolean = false\r\n): LazySet<T> {\r\n\tif (set === null) {\r\n\t\treturn item;\r\n\t}\r\n\tif (Array.isArray(set)) {\r\n\t\tif (set.indexOf(item) === -1) {\r\n\t\t\tif (setIsImmutable) {\r\n\t\t\t\tset = set.slice();\r\n\t\t\t}\r\n\t\t\tset.push(item);\r\n\t\t}\r\n\t\treturn set;\r\n\t}\r\n\tif (set === item) {\r\n\t\treturn set;\r\n\t}\r\n\treturn [set, item];\r\n}\r\n\r\n/**\r\n * Returns a LazySet representing the union of the given sets.\r\n *\r\n * @param set1            - First set\r\n * @param set2            - Second set\r\n * @param setIsImmutable - If left at false, when set1 is an array, items in set2 are pushed into\r\n *                         the existing array. If set to true, a new array will be allocated\r\n *                         instead. This can be used to prevent mutation of an existing set if you\r\n *                         need to keep the original value.\r\n */\r\nexport function mergeLazySets<T>(\r\n\tset1: LazySet<T>,\r\n\tset2: LazySet<T>,\r\n\tset1IsImmutable: boolean\r\n): LazySet<T> {\r\n\tif (set1 === null) {\r\n\t\treturn set2;\r\n\t}\r\n\tif (set2 === null) {\r\n\t\treturn set1;\r\n\t}\r\n\tif (Array.isArray(set2)) {\r\n\t\treturn set2.reduce(\r\n\t\t\t(set: LazySet<T>, item: T) => addToLazySet(set, item, set === set2),\r\n\t\t\tset1\r\n\t\t);\r\n\t}\r\n\treturn addToLazySet(set1, set2, set1IsImmutable);\r\n}\r\n","/**\r\n * A Trace represents the execution history of a Thread in terms of the records gathered. Only paths\r\n * that differ in terms of these records are preserved.\r\n *\r\n * Trace is never cyclic (i.e., a given Trace is never included in its prefixes, including,\r\n * recursively, the prefixes thereof).\r\n *\r\n * Trace instances are often reused and should therefore never be mutated after creation.\r\n */\r\nexport default class Trace<TRecord> {\r\n\tconstructor(\r\n\t\tpublic readonly prefixes: Trace<TRecord>[],\r\n\t\tpublic readonly record: TRecord | null\r\n\t) {}\r\n\r\n\t/**\r\n\t * Single instance used to represent the empty trace from which all programs start.\r\n\t */\r\n\tstatic EMPTY = new Trace<any>([], null);\r\n}\r\n","import FromBuffer from './FromBuffer';\r\nimport { LazySet, mergeLazySets } from './LazySet';\r\nimport Trace from './Trace';\r\n\r\n/**\r\n * Create a trace only when necessary.\r\n *\r\n * Not adding records to a single prefix can be represented by the prefix itself. Similarly, adding\r\n * a record to only the empty trace can omit the empty trace from the prefixes of the new trace.\r\n *\r\n * Finally, if the LazySet of prefixes was already an array, this reuses that array in the trace,\r\n * avoiding an extra allocation.\r\n *\r\n * @param prefixes - Non-empty LazySet of Trace instances, representing the unique ways to get here\r\n * @param record   - Optional record to include in the Trace\r\n */\r\nfunction createOrReuseTrace<TRecord>(\r\n\tprefixes: Exclude<LazySet<Trace<TRecord>>, null>,\r\n\trecord: TRecord | null\r\n): Trace<TRecord> {\r\n\tlet prefixesArray: Trace<TRecord>[];\r\n\tif (record === null) {\r\n\t\tif (!Array.isArray(prefixes)) {\r\n\t\t\treturn prefixes;\r\n\t\t}\r\n\t\tprefixesArray = prefixes;\r\n\t} else if (prefixes === Trace.EMPTY) {\r\n\t\t// No need to include empty prefixes on the new trace with a record\r\n\t\tprefixesArray = [];\r\n\t} else if (Array.isArray(prefixes)) {\r\n\t\tprefixesArray = prefixes;\r\n\t} else {\r\n\t\tprefixesArray = [prefixes];\r\n\t}\r\n\r\n\treturn new Trace(prefixesArray, record);\r\n}\r\n\r\n/**\r\n * Used to ensure that each instruction is visited only once per survivor, and to abort cyclic paths\r\n * so traces constructed never form cycles.\r\n */\r\nconst enum TracingState {\r\n\tNOT_VISITED,\r\n\tIN_CURRENT_PATH,\r\n\tDONE\r\n}\r\n\r\n/**\r\n * Handles updating Trace instances across each generation, while minimizing allocations.\r\n */\r\nexport default class Tracer<TRecord> {\r\n\tprivate readonly _stateByPc: TracingState[] = [];\r\n\tprivate readonly _prefixesByPc: LazySet<Trace<TRecord>>[] = [];\r\n\r\n\tconstructor(programLength: number) {\r\n\t\tfor (let i = 0; i < programLength; ++i) {\r\n\t\t\tthis._stateByPc.push(TracingState.NOT_VISITED);\r\n\t\t\tthis._prefixesByPc.push(null);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Determines traces for each entry in startingFromBuffer for pc, and adds them to prefixes,\r\n\t * returning the resulting LazySet.\r\n\t *\r\n\t * Steps taken by trace() after the first step use the fromByPc FromBuffer instead of the\r\n\t * startingFromBuffer. This supports the fact that the first step is always from a survivor, so\r\n\t * should be taken in the survivor from buffer, while the rest of the steps are within the\r\n\t * generation.\r\n\t */\r\n\tprivate mergeTraces(\r\n\t\tprefixes: LazySet<Trace<TRecord>>,\r\n\t\tpc: number,\r\n\t\tstartingFromBuffer: FromBuffer,\r\n\t\tpreviousTraceBySurvivorPc: (Trace<TRecord> | null)[],\r\n\t\tfromByPc: FromBuffer,\r\n\t\trecordByPc: (TRecord | null)[]\r\n\t): LazySet<Trace<TRecord>> {\r\n\t\tlet isPrefixesReused = false;\r\n\t\tstartingFromBuffer.forEach(pc, fromPc => {\r\n\t\t\tconst traces = this.trace(fromPc, previousTraceBySurvivorPc, fromByPc, recordByPc);\r\n\t\t\tprefixes = mergeLazySets(prefixes, traces, isPrefixesReused);\r\n\t\t\tisPrefixesReused = prefixes === traces;\r\n\t\t});\r\n\t\treturn prefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines traces leading to pc, stepping through fromByPc and using incoming traces (i.e.,\r\n\t * from a previous generation) from previousTraceBySurvivorPc.\r\n\t *\r\n\t * To prevent allocations, traces are represented as a LazySet of their prefixes for as long as\r\n\t * possible, which usually means until a record has to be added.\r\n\t *\r\n\t * @param pc                        - The pc from which to trace\r\n\t * @param previousTraceBySurvivorPc - Incoming traces (built up in the previous generation)\r\n\t * @param fromByPc                  - The FromBuffer to trace through\r\n\t * @param recordByPc                - Records to include when a trace passes through the\r\n\t *                                    corresponding pc.\r\n\t */\r\n\tprivate trace(\r\n\t\tpc: number,\r\n\t\tpreviousTraceBySurvivorPc: (Trace<TRecord> | null)[],\r\n\t\tfromByPc: FromBuffer,\r\n\t\trecordByPc: (TRecord | null)[]\r\n\t): LazySet<Trace<TRecord>> {\r\n\t\tconst state = this._stateByPc[pc];\r\n\t\tswitch (state) {\r\n\t\t\tcase TracingState.DONE:\r\n\t\t\t\treturn this._prefixesByPc[pc];\r\n\r\n\t\t\tcase TracingState.IN_CURRENT_PATH:\r\n\t\t\t\t// Trace is a cycle, ignore this path\r\n\t\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// Mark state to detect cycles\r\n\t\tthis._stateByPc[pc] = TracingState.IN_CURRENT_PATH;\r\n\r\n\t\tlet prefixes: LazySet<Trace<TRecord>> = null;\r\n\t\tconst startingTrace = previousTraceBySurvivorPc[pc];\r\n\t\tif (startingTrace !== null) {\r\n\t\t\tprefixes = startingTrace;\r\n\t\t} else if (!fromByPc.has(pc)) {\r\n\t\t\tthrow new Error(`Trace without source at pc ${pc}`);\r\n\t\t}\r\n\t\tprefixes = this.mergeTraces(\r\n\t\t\tprefixes,\r\n\t\t\tpc,\r\n\t\t\tfromByPc,\r\n\t\t\tpreviousTraceBySurvivorPc,\r\n\t\t\tfromByPc,\r\n\t\t\trecordByPc\r\n\t\t);\r\n\r\n\t\tif (prefixes !== null) {\r\n\t\t\t// Valid prefixes found, check for records\r\n\t\t\tconst record = recordByPc[pc];\r\n\t\t\tif (record !== null) {\r\n\t\t\t\tprefixes = createOrReuseTrace(prefixes, record);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Add to cache and mark as complete\r\n\t\tthis._prefixesByPc[pc] = prefixes;\r\n\t\tthis._stateByPc[pc] = TracingState.DONE;\r\n\t\treturn prefixes;\r\n\t}\r\n\r\n\t/**\r\n\t * Populates newTraceBySurvivorPc with traces constructed from tracing for any survivor (i.e.,\r\n\t * those pcs having any entries in fromBySurvivorPc). Tracing takes the first step in\r\n\t * fromBySurvivorPc and then proceeds through fromByPc until complete, gathering unique traces\r\n\t * by combining incoming traces (from previousTraceBySurvivorPc) with new records (from\r\n\t * recordByPc) gathered along the way.\r\n\t *\r\n\t * @param previousTraceBySurvivorPc - Incoming traces (built up in the previous generation)\r\n\t * @param newTraceBySurvivorPc      - Array to populate with new traces (or null for\r\n\t *                                    non-survivor pcs)\r\n\t * @param fromBySurvivorPc          - The FromBuffer with the final steps for each thread (from\r\n\t *                                    within the generation to being a survivor)\r\n\t * @param fromByPc                  - The FromBuffer with all other steps taken within the\r\n\t *                                    generation.\r\n\t * @param recordByPc                - Records generated during the generation.\r\n\t */\r\n\tpublic buildSurvivorTraces(\r\n\t\tpreviousTraceBySurvivorPc: (Trace<TRecord> | null)[],\r\n\t\tnewTraceBySurvivorPc: (Trace<TRecord> | null)[],\r\n\t\tfromBySurvivorPc: FromBuffer,\r\n\t\tfromByPc: FromBuffer,\r\n\t\trecordByPc: (TRecord | null)[]\r\n\t): void {\r\n\t\tfor (\r\n\t\t\tlet pc = 0, programLength = previousTraceBySurvivorPc.length;\r\n\t\t\tpc < programLength;\r\n\t\t\t++pc\r\n\t\t) {\r\n\t\t\tif (!fromBySurvivorPc.has(pc)) {\r\n\t\t\t\tnewTraceBySurvivorPc[pc] = null;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// Some cached results may depend on detected cycles. The points at which a cycle should\r\n\t\t\t// no longer be followed differ between survivors, so these cached results are not\r\n\t\t\t// transferrable between them. To work around this, we reset the tracing state and cache\r\n\t\t\t// before tracing each survivor, and later deduplicate results in Traces.getTraces().\r\n\t\t\tthis._prefixesByPc.fill(null);\r\n\t\t\tthis._stateByPc.fill(TracingState.NOT_VISITED);\r\n\t\t\tconst prefixes: LazySet<Trace<TRecord>> = this.mergeTraces(\r\n\t\t\t\tnull,\r\n\t\t\t\tpc,\r\n\t\t\t\tfromBySurvivorPc,\r\n\t\t\t\tpreviousTraceBySurvivorPc,\r\n\t\t\t\tfromByPc,\r\n\t\t\t\trecordByPc\r\n\t\t\t);\r\n\t\t\tif (prefixes === null) {\r\n\t\t\t\tthrow new Error(`No non-cyclic paths found to survivor ${pc}`);\r\n\t\t\t}\r\n\t\t\tnewTraceBySurvivorPc[pc] = createOrReuseTrace(prefixes, null);\r\n\t\t}\r\n\t\t// Free prefix sets for GC\r\n\t\tthis._prefixesByPc.fill(null);\r\n\t}\r\n}\r\n","import FromBuffer from './FromBuffer';\r\nimport { addToLazySet, LazySet } from './LazySet';\r\nimport ProgramInfo from './ProgramInfo';\r\nimport Trace from './Trace';\r\nimport Tracer from './Tracer';\r\n\r\n/**\r\n * Records information needed to build Trace instances after each generation concludes.\r\n */\r\nexport default class Traces<TRecord> {\r\n\t/**\r\n\t * Incoming steps (in terms of the pc these originated from by target pc), for steps within the\r\n\t * current generation.\r\n\t */\r\n\tprivate readonly _fromByPc: FromBuffer;\r\n\r\n\t/**\r\n\t * Incoming steps (in terms of the pc these originated from by target pc), for steps that lead\r\n\t * to the next generation.\r\n\t */\r\n\tprivate readonly _fromBySurvivorPc: FromBuffer;\r\n\r\n\t/**\r\n\t * Records generated, by pc, in the current generation\r\n\t */\r\n\tprivate readonly _recordByPc: (TRecord | null)[] = [];\r\n\r\n\t/**\r\n\t * Traces for anything that survived until the start of the generation, updated when the current\r\n\t * generation ends. Swaps with _nextTraceBySurvivorPc after each generation in order to minimize\r\n\t * allocations.\r\n\t */\r\n\tprivate _traceBySurvivorPc: (Trace<TRecord> | null)[] = [];\r\n\r\n\t/**\r\n\t * Array in which to build traces for the next generation when the current one ends. Swaps with\r\n\t * _traceBySurvivorPc after each generation in order to minimize allocations.\r\n\t */\r\n\tprivate _nextTraceBySurvivorPc: (Trace<TRecord> | null)[] = [];\r\n\r\n\t/**\r\n\t * Helper used for updating traces between generations.\r\n\t */\r\n\tprivate readonly _tracer: Tracer<TRecord>;\r\n\r\n\tconstructor(programInfo: ProgramInfo) {\r\n\t\tthis._fromByPc = new FromBuffer(programInfo.maxFromByPc);\r\n\t\tthis._fromBySurvivorPc = new FromBuffer(programInfo.maxSurvivorFromByPc);\r\n\t\tthis._tracer = new Tracer(programInfo.programLength);\r\n\t\tfor (let i = 0; i < programInfo.programLength; ++i) {\r\n\t\t\tthis._recordByPc.push(null);\r\n\t\t\tthis._traceBySurvivorPc.push(null);\r\n\t\t\tthis._nextTraceBySurvivorPc.push(null);\r\n\t\t}\r\n\r\n\t\tthis._traceBySurvivorPc[0] = Trace.EMPTY;\r\n\t}\r\n\r\n\t/**\r\n\t * Clear the instance after each generation or for a new run of the VM.\r\n\t *\r\n\t * @param clearSurvivors - Set to true to clear survivor traces when resetting for a new run.\r\n\t *                         Set to false when moving to the next generation to preserve these.\r\n\t */\r\n\tpublic reset(clearSurvivors: boolean): void {\r\n\t\tthis._fromByPc.clear();\r\n\t\tthis._fromBySurvivorPc.clear();\r\n\r\n\t\tthis._recordByPc.fill(null);\r\n\r\n\t\tif (clearSurvivors) {\r\n\t\t\tthis._traceBySurvivorPc.fill(null);\r\n\t\t\tthis._nextTraceBySurvivorPc.fill(null);\r\n\t\t\tthis._traceBySurvivorPc[0] = Trace.EMPTY;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Add a record for the current generation\r\n\t *\r\n\t * @param pc     - The pc of the record instruction this record originates from\r\n\t * @param record - The data to record\r\n\t */\r\n\tpublic record(pc: number, record: TRecord): void {\r\n\t\tthis._recordByPc[pc] = record;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the given instruction has already been visited during the current generation.\r\n\t *\r\n\t * This is determined by it having incoming entries in the corresponding FromBuffer, or by it\r\n\t * having an incoming trace from the previous generation.\r\n\t *\r\n\t * @param pc The pc to check.\r\n\t */\r\n\tpublic has(pc: number): boolean {\r\n\t\treturn this._fromByPc.has(pc) || this._traceBySurvivorPc[pc] !== null;\r\n\t}\r\n\r\n\t/**\r\n\t * Record the given step within the current generation.\r\n\t *\r\n\t * @param fromPc - Origin of the step\r\n\t * @param toPc   - Target of the step\r\n\t */\r\n\tpublic add(fromPc: number, toPc: number): void {\r\n\t\tthis._fromByPc.add(fromPc, toPc);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the given instruction has been stepped to for the next generation.\r\n\t *\r\n\t * This is determined by it having incoming entries in the corresponding FromBuffer.\r\n\t *\r\n\t * @param pc The pc to check.\r\n\t */\r\n\tpublic hasSurvivor(pc: number): boolean {\r\n\t\treturn this._fromBySurvivorPc.has(pc);\r\n\t}\r\n\r\n\t/**\r\n\t * Record the given step from the current generation to the next.\r\n\t *\r\n\t * @param fromPc - Origin of the step\r\n\t * @param toPc   - Target of the step\r\n\t */\r\n\tpublic addSurvivor(fromPc: number, toPc: number): void {\r\n\t\tthis._fromBySurvivorPc.add(fromPc, toPc);\r\n\t}\r\n\r\n\t/**\r\n\t * Builds traces for each survivor after a generation ends.\r\n\t *\r\n\t * Swaps the _traceBySurvivorPc and _nextTraceBySurvivorPc arrays afterwards to avoid\r\n\t * allocations.\r\n\t */\r\n\tpublic buildSurvivorTraces(): void {\r\n\t\tconst previousTraceBySurvivorPc = this._traceBySurvivorPc;\r\n\t\tthis._tracer.buildSurvivorTraces(\r\n\t\t\tpreviousTraceBySurvivorPc,\r\n\t\t\tthis._nextTraceBySurvivorPc,\r\n\t\t\tthis._fromBySurvivorPc,\r\n\t\t\tthis._fromByPc,\r\n\t\t\tthis._recordByPc\r\n\t\t);\r\n\t\t// Swap arrays\r\n\t\tthis._traceBySurvivorPc = this._nextTraceBySurvivorPc;\r\n\t\tthis._nextTraceBySurvivorPc = previousTraceBySurvivorPc;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns unique traces for all threads that reached accept after all input has been processed.\r\n\t *\r\n\t * Should be called after the last generation finishes.\r\n\t *\r\n\t * @param acceptedPcs - The pcs for which to compute traces. These should all have survived the\r\n\t *                      last generation.\r\n\t */\r\n\tpublic getTraces(acceptedPcs: number[]): Trace<TRecord>[] {\r\n\t\tconst traces = acceptedPcs.reduce(\r\n\t\t\t(traces: LazySet<Trace<TRecord>>, pc: number) =>\r\n\t\t\t\taddToLazySet(traces, this._traceBySurvivorPc[pc]!),\r\n\t\t\tnull\r\n\t\t);\r\n\t\tif (traces === null) {\r\n\t\t\treturn [];\r\n\t\t}\r\n\t\treturn Array.isArray(traces) ? traces : [traces];\r\n\t}\r\n}\r\n","import Generation from './Generation';\r\nimport ProgramInfo from './ProgramInfo';\r\nimport Trace from './Trace';\r\nimport Traces from './Traces';\r\n\r\n/**\r\n * Responsible for tracking all execution state for a running VM.\r\n *\r\n * This manages scheduling of threads for the current and next generation using two instances of\r\n * Generation. It also handles tracking steps for the current generation and updating Trace\r\n * instances for any survivors (i.e., threads that made it to the next generation) using a Traces\r\n * instance.\r\n *\r\n * Note that threads are not represented directly. Generation only schedules program counter (pc)\r\n * values with a corresponding badness. Traces only tracks steps taken through the program. At the\r\n * end of all input, we're only interested in the unique paths taken to get there in terms of the\r\n * records collected along the way.\r\n */\r\nexport default class Scheduler<TRecord> {\r\n\tprivate _currentGeneration: Generation;\r\n\tprivate _nextGeneration: Generation;\r\n\r\n\t// Trace data for the current generation\r\n\tprivate readonly _traces: Traces<TRecord>;\r\n\r\n\t// PCs of accepted threads in the current generation\r\n\tprivate readonly _acceptedPcs: number[] = [];\r\n\r\n\tconstructor(programInfo: ProgramInfo) {\r\n\t\tthis._currentGeneration = new Generation(programInfo.programLength);\r\n\t\tthis._nextGeneration = new Generation(programInfo.programLength);\r\n\t\tthis._traces = new Traces(programInfo);\r\n\t}\r\n\r\n\t/**\r\n\t * Clears all information for a new run of the program.\r\n\t */\r\n\tpublic reset(): void {\r\n\t\tthis._currentGeneration.reset();\r\n\t\tthis._currentGeneration.add(0, 0);\r\n\r\n\t\tthis._acceptedPcs.length = 0;\r\n\t\tthis._traces.reset(true);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the pc for the next thread to execute, or null if there are no more threads to run in the\r\n\t * current generation.\r\n\t */\r\n\tpublic getNextThreadPc(): number | null {\r\n\t\treturn this._currentGeneration.getNextPc();\r\n\t}\r\n\r\n\t/**\r\n\t * Step the thread forward, updating traces and scheduling the new thread in the current\r\n\t * generation.\r\n\t *\r\n\t * @param fromPc       - The current pc being executed\r\n\t * @param toPc         - The pc at which to continue\r\n\t * @param badnessDelta - The amount by which to increase badness for toPc\r\n\t */\r\n\tpublic step(fromPc: number, toPc: number, badnessDelta: number) {\r\n\t\tconst alreadyScheduled = this._traces.has(toPc);\r\n\t\tthis._traces.add(fromPc, toPc);\r\n\r\n\t\tconst badness = this._currentGeneration.getBadness(fromPc) + badnessDelta;\r\n\t\tif (alreadyScheduled) {\r\n\t\t\tthis._currentGeneration.reschedule(toPc, badness);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Schedule the next step\r\n\t\tthis._currentGeneration.add(toPc, badness);\r\n\t}\r\n\r\n\t/**\r\n\t * Step the thread forward, updating traces and scheduling the new thread in the next\r\n\t * generation.\r\n\t *\r\n\t * @param fromPc       - The current pc being executed\r\n\t * @param toPc         - The pc at which to continue\r\n\t */\r\n\tpublic stepToNextGeneration(fromPc: number, toPc: number) {\r\n\t\tconst alreadyScheduled = this._traces.hasSurvivor(toPc);\r\n\t\tthis._traces.addSurvivor(fromPc, toPc);\r\n\r\n\t\tconst badness = this._currentGeneration.getBadness(fromPc);\r\n\t\tif (alreadyScheduled) {\r\n\t\t\tthis._nextGeneration.reschedule(toPc, badness);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._nextGeneration.add(toPc, badness);\r\n\t}\r\n\r\n\t/**\r\n\t * Marks the thread ending at pc as successful (i.e., it executed an accept instruction when all\r\n\t * input has been processed). The trace for pc will be included in the result returned from\r\n\t * VM.execute().\r\n\t *\r\n\t * @param pc - The current pc being executed (corresponding to an accept instruction)\r\n\t */\r\n\tpublic accept(pc: number): void {\r\n\t\tthis._acceptedPcs.push(pc);\r\n\t\tthis._traces.addSurvivor(pc, pc);\r\n\t}\r\n\r\n\t/**\r\n\t * Marks the thread ending at pc as failed, i.e., it was stopped from continuing execution. This\r\n\t * could happen in the following cases:\r\n\t *\r\n\t * - it executed an accept instruction while not all input has been processed\r\n\t * - it executed a fail instruction (for which the callback returned true if there was one)\r\n\t * - it executed a test instruction for which the callback returned false\r\n\t * - it executed a jump instruction with no targets\r\n\t *\r\n\t * This does not currently do anything, but could be used to determine an explanation why input\r\n\t * was not accepted by the VM in a future version.\r\n\t *\r\n\t * @param _pc - The current pc being executed (corresponding to one of the cases mentioned)\r\n\t */\r\n\tpublic fail(_pc: number): void {\r\n\t\t// TODO: track failures as the combination of input x instruction?\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a record for traces that include the pc.\r\n\t *\r\n\t * @param pc     - The pc for which to add the record, corresponding to a record instruction.\r\n\t * @param record - The record to add.\r\n\t */\r\n\tpublic record(pc: number, record: TRecord): void {\r\n\t\tthis._traces.record(pc, record);\r\n\t}\r\n\r\n\t/**\r\n\t * Updates traces for survivors and switches to the next generation. To be called when there are\r\n\t * no more threads scheduled in the current generation (i.e., getNextThreadPc returns null).\r\n\t */\r\n\tpublic nextGeneration(): void {\r\n\t\tthis._traces.buildSurvivorTraces();\r\n\r\n\t\tthis._traces.reset(false);\r\n\r\n\t\tconst gen = this._currentGeneration;\r\n\t\tgen.reset();\r\n\t\tthis._currentGeneration = this._nextGeneration;\r\n\t\tthis._nextGeneration = gen;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the unique traces for all accepted pcs. To be called after the generation for the\r\n\t * last input item has completed.\r\n\t */\r\n\tpublic getAcceptingTraces(): Trace<TRecord>[] {\r\n\t\treturn this._traces.getTraces(this._acceptedPcs);\r\n\t}\r\n}\r\n","import { Instruction, FailFunc, RecordFunc, TestFunc, Operation } from './Instruction';\r\nimport ProgramInfo from './ProgramInfo';\r\nimport Result from './Result';\r\nimport Scheduler from './Scheduler';\r\n\r\n/**\r\n * A virtual machine to execute whynot programs.\r\n *\r\n * @public\r\n */\r\nexport default class VM<TInput, TRecord, TOptions = void> {\r\n\tprivate readonly _program: Instruction<TInput, TRecord, TOptions>[];\r\n\tprivate readonly _programInfo: ProgramInfo;\r\n\tprivate readonly _schedulers: Scheduler<TRecord>[] = [];\r\n\r\n\t/**\r\n\t * @param program - The program to run, as created by the Assembler\r\n\t */\r\n\tconstructor(program: Instruction<TInput, TRecord, TOptions>[]) {\r\n\t\tthis._program = program;\r\n\t\tthis._programInfo = ProgramInfo.fromProgram(program);\r\n\t\tthis._schedulers.push(new Scheduler(this._programInfo));\r\n\t}\r\n\r\n\t/**\r\n\t * Executes the program in the VM with the given input stream.\r\n\t *\r\n\t * @param input   - An array of input items.\r\n\t * @param options - Optional object passed to all instruction callbacks.\r\n\t *\r\n\t * @returns Result of the execution, containing all Traces that lead to acceptance of the input\r\n\t *          (if any)\r\n\t */\r\n\texecute(input: TInput[], options?: TOptions): Result<TRecord> {\r\n\t\tconst scheduler = this._schedulers.pop() || new Scheduler(this._programInfo);\r\n\r\n\t\t// Add initial thread\r\n\t\tscheduler.reset();\r\n\r\n\t\tconst inputLength = input.length;\r\n\t\tlet inputIndex = -1;\r\n\t\tlet inputItem: TInput | null;\r\n\t\tdo {\r\n\t\t\t// Get next thread to execute\r\n\t\t\tlet pc = scheduler.getNextThreadPc();\r\n\t\t\tif (pc === null) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\t// Read next input item\r\n\t\t\t++inputIndex;\r\n\t\t\tinputItem = inputIndex >= inputLength ? null : input[inputIndex];\r\n\r\n\t\t\twhile (pc !== null) {\r\n\t\t\t\tconst instruction: Instruction<TInput, TRecord, TOptions> = this._program[pc];\r\n\r\n\t\t\t\tswitch (instruction.op) {\r\n\t\t\t\t\tcase Operation.ACCEPT:\r\n\t\t\t\t\t\t// Only accept if we reached the end of the input\r\n\t\t\t\t\t\tif (inputItem === null) {\r\n\t\t\t\t\t\t\tscheduler.accept(pc);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tscheduler.fail(pc);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase Operation.FAIL: {\r\n\t\t\t\t\t\t// Is the failure conditional?\r\n\t\t\t\t\t\tconst func = instruction.func as FailFunc<TOptions> | null;\r\n\t\t\t\t\t\tconst isFailingCondition = func === null || func(options);\r\n\t\t\t\t\t\tif (isFailingCondition) {\r\n\t\t\t\t\t\t\t// Branch is forbidden, end the thread\r\n\t\t\t\t\t\t\tscheduler.fail(pc);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Condition failed, continue at next instruction\r\n\t\t\t\t\t\tscheduler.step(pc, pc + 1, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase Operation.BAD:\r\n\t\t\t\t\t\t// Continue at next pc with added badness\r\n\t\t\t\t\t\tscheduler.step(pc, pc + 1, instruction.data as number);\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase Operation.TEST: {\r\n\t\t\t\t\t\t// Fail if out of input\r\n\t\t\t\t\t\tif (inputItem === null) {\r\n\t\t\t\t\t\t\tscheduler.fail(pc);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Fail if input does not match\r\n\t\t\t\t\t\tconst func = instruction.func as TestFunc<TInput, TOptions>;\r\n\t\t\t\t\t\tconst isInputAccepted = func(inputItem, instruction.data, options);\r\n\t\t\t\t\t\tif (!isInputAccepted) {\r\n\t\t\t\t\t\t\tscheduler.fail(pc);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Continue in next generation, preserving badness\r\n\t\t\t\t\t\tscheduler.stepToNextGeneration(pc, pc + 1);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase Operation.JUMP: {\r\n\t\t\t\t\t\t// Spawn new threads for all targets\r\n\t\t\t\t\t\tconst targetPcs = instruction.data as number[];\r\n\t\t\t\t\t\tconst numTargets = targetPcs.length;\r\n\t\t\t\t\t\tif (numTargets === 0) {\r\n\t\t\t\t\t\t\tscheduler.fail(pc);\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor (let i = 0; i < numTargets; ++i) {\r\n\t\t\t\t\t\t\tscheduler.step(pc, targetPcs[i], 0);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase Operation.RECORD: {\r\n\t\t\t\t\t\t// Invoke record callback\r\n\t\t\t\t\t\tconst func = instruction.func as RecordFunc<TRecord, TOptions>;\r\n\t\t\t\t\t\tconst record = func(instruction.data, inputIndex, options);\r\n\t\t\t\t\t\tif (record !== null && record !== undefined) {\r\n\t\t\t\t\t\t\tscheduler.record(pc, record);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// Continue with next instruction\r\n\t\t\t\t\t\tscheduler.step(pc, pc + 1, 0);\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Next thread\r\n\t\t\t\tpc = scheduler.getNextThreadPc();\r\n\t\t\t}\r\n\r\n\t\t\t// End current Generation and continue with the next\r\n\t\t\tscheduler.nextGeneration();\r\n\t\t} while (inputItem !== null);\r\n\r\n\t\tconst result = new Result(scheduler.getAcceptingTraces());\r\n\r\n\t\t// Clear and recycle the scheduler\r\n\t\tscheduler.reset();\r\n\t\tthis._schedulers.push(scheduler);\r\n\r\n\t\treturn result;\r\n\t}\r\n}\r\n","import Assembler from './Assembler';\r\nimport VM from './VM';\r\n\r\nexport { default as Assembler } from './Assembler';\r\nexport { default as VM } from './VM';\r\n\r\n/**\r\n * Convenience helper function that creates a new VM using the specified callback for compilation.\r\n *\r\n * @public\r\n *\r\n * @param compile - Function used to compile the program, invoked with an Assembler as the only\r\n *                  parameter.\r\n *\r\n * @returns VM running the compiled program\r\n */\r\nexport function compileVM<TInput, TRecord = void, TOptions = void>(\r\n\tcompile: (assembler: Assembler<TInput, TRecord, TOptions>) => void\r\n): VM<TInput, TRecord, TOptions> {\r\n\tconst assembler = new Assembler<TInput, TRecord, TOptions>();\r\n\tcompile(assembler);\r\n\treturn new VM<TInput, TRecord, TOptions>(assembler.program);\r\n}\r\n\r\nexport default { Assembler, VM, compileVM };\r\n"],"names":["addInstruction","program","op","func","data","instruction","push","defaultRecorder","_inputIndex","Assembler","[object Object]","this","matcher","undefined","targets","recorder","cost","predicate","ProgramInfo","programLength","maxFromByPc","maxSurvivorFromByPc","length","forEach","_","pc","Error","targetPc","i","Result","acceptingTraces","success","MAX_BADNESS","Generation","_scheduledPcs","Uint16Array","_badnessByPc","Uint8Array","badness","insertionIndex","pcs","badnessByPc","first","low","high","mid","findInsertionIndex","_nextThread","_numScheduledPcs","copyWithin","maxBadness","Math","max","existingThreadIndex","indexOf","add","fill","FromBuffer","offset","_mapping","_buffer","fromPc","toPc","callback","addToLazySet","set","item","setIsImmutable","Array","isArray","slice","Trace","prefixes","record","createOrReuseTrace","prefixesArray","EMPTY","Tracer","_stateByPc","_prefixesByPc","startingFromBuffer","previousTraceBySurvivorPc","fromByPc","recordByPc","isPrefixesReused","traces","trace","set1","set2","set1IsImmutable","reduce","startingTrace","has","mergeTraces","newTraceBySurvivorPc","fromBySurvivorPc","Traces","programInfo","_fromByPc","_fromBySurvivorPc","_tracer","_recordByPc","_traceBySurvivorPc","_nextTraceBySurvivorPc","clearSurvivors","clear","buildSurvivorTraces","acceptedPcs","Scheduler","_currentGeneration","_nextGeneration","_traces","reset","_acceptedPcs","getNextPc","badnessDelta","alreadyScheduled","getBadness","reschedule","hasSurvivor","addSurvivor","_pc","gen","getTraces","VM","_program","_programInfo","fromProgram","_schedulers","input","options","scheduler","pop","inputLength","inputItem","inputIndex","getNextThreadPc","accept","fail","step","stepToNextGeneration","targetPcs","numTargets","nextGeneration","result","getAcceptingTraces","compileVM","compile","assembler"],"mappings":"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"}